// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/maisiq/go-auth-service/internal/repository.ITokenRepository -o i_token_repository_mock.go -n ITokenRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ITokenRepositoryMock implements mm_repository.ITokenRepository
type ITokenRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAdd          func(ctx context.Context, key string, value string, expiration time.Duration) (err error)
	funcAddOrigin    string
	inspectFuncAdd   func(ctx context.Context, key string, value string, expiration time.Duration)
	afterAddCounter  uint64
	beforeAddCounter uint64
	AddMock          mITokenRepositoryMockAdd

	funcDelete          func(ctx context.Context, keys ...string) (err error)
	funcDeleteOrigin    string
	inspectFuncDelete   func(ctx context.Context, keys ...string)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mITokenRepositoryMockDelete

	funcGet          func(ctx context.Context, key string) (s1 string, err error)
	funcGetOrigin    string
	inspectFuncGet   func(ctx context.Context, key string)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mITokenRepositoryMockGet

	funcList          func(ctx context.Context, key string) (sa1 []string, err error)
	funcListOrigin    string
	inspectFuncList   func(ctx context.Context, key string)
	afterListCounter  uint64
	beforeListCounter uint64
	ListMock          mITokenRepositoryMockList

	funcPush          func(ctx context.Context, key string, values ...string) (err error)
	funcPushOrigin    string
	inspectFuncPush   func(ctx context.Context, key string, values ...string)
	afterPushCounter  uint64
	beforePushCounter uint64
	PushMock          mITokenRepositoryMockPush
}

// NewITokenRepositoryMock returns a mock for mm_repository.ITokenRepository
func NewITokenRepositoryMock(t minimock.Tester) *ITokenRepositoryMock {
	m := &ITokenRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddMock = mITokenRepositoryMockAdd{mock: m}
	m.AddMock.callArgs = []*ITokenRepositoryMockAddParams{}

	m.DeleteMock = mITokenRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*ITokenRepositoryMockDeleteParams{}

	m.GetMock = mITokenRepositoryMockGet{mock: m}
	m.GetMock.callArgs = []*ITokenRepositoryMockGetParams{}

	m.ListMock = mITokenRepositoryMockList{mock: m}
	m.ListMock.callArgs = []*ITokenRepositoryMockListParams{}

	m.PushMock = mITokenRepositoryMockPush{mock: m}
	m.PushMock.callArgs = []*ITokenRepositoryMockPushParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mITokenRepositoryMockAdd struct {
	optional           bool
	mock               *ITokenRepositoryMock
	defaultExpectation *ITokenRepositoryMockAddExpectation
	expectations       []*ITokenRepositoryMockAddExpectation

	callArgs []*ITokenRepositoryMockAddParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ITokenRepositoryMockAddExpectation specifies expectation struct of the ITokenRepository.Add
type ITokenRepositoryMockAddExpectation struct {
	mock               *ITokenRepositoryMock
	params             *ITokenRepositoryMockAddParams
	paramPtrs          *ITokenRepositoryMockAddParamPtrs
	expectationOrigins ITokenRepositoryMockAddExpectationOrigins
	results            *ITokenRepositoryMockAddResults
	returnOrigin       string
	Counter            uint64
}

// ITokenRepositoryMockAddParams contains parameters of the ITokenRepository.Add
type ITokenRepositoryMockAddParams struct {
	ctx        context.Context
	key        string
	value      string
	expiration time.Duration
}

// ITokenRepositoryMockAddParamPtrs contains pointers to parameters of the ITokenRepository.Add
type ITokenRepositoryMockAddParamPtrs struct {
	ctx        *context.Context
	key        *string
	value      *string
	expiration *time.Duration
}

// ITokenRepositoryMockAddResults contains results of the ITokenRepository.Add
type ITokenRepositoryMockAddResults struct {
	err error
}

// ITokenRepositoryMockAddOrigins contains origins of expectations of the ITokenRepository.Add
type ITokenRepositoryMockAddExpectationOrigins struct {
	origin           string
	originCtx        string
	originKey        string
	originValue      string
	originExpiration string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAdd *mITokenRepositoryMockAdd) Optional() *mITokenRepositoryMockAdd {
	mmAdd.optional = true
	return mmAdd
}

// Expect sets up expected params for ITokenRepository.Add
func (mmAdd *mITokenRepositoryMockAdd) Expect(ctx context.Context, key string, value string, expiration time.Duration) *mITokenRepositoryMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("ITokenRepositoryMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &ITokenRepositoryMockAddExpectation{}
	}

	if mmAdd.defaultExpectation.paramPtrs != nil {
		mmAdd.mock.t.Fatalf("ITokenRepositoryMock.Add mock is already set by ExpectParams functions")
	}

	mmAdd.defaultExpectation.params = &ITokenRepositoryMockAddParams{ctx, key, value, expiration}
	mmAdd.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAdd.expectations {
		if minimock.Equal(e.params, mmAdd.defaultExpectation.params) {
			mmAdd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAdd.defaultExpectation.params)
		}
	}

	return mmAdd
}

// ExpectCtxParam1 sets up expected param ctx for ITokenRepository.Add
func (mmAdd *mITokenRepositoryMockAdd) ExpectCtxParam1(ctx context.Context) *mITokenRepositoryMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("ITokenRepositoryMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &ITokenRepositoryMockAddExpectation{}
	}

	if mmAdd.defaultExpectation.params != nil {
		mmAdd.mock.t.Fatalf("ITokenRepositoryMock.Add mock is already set by Expect")
	}

	if mmAdd.defaultExpectation.paramPtrs == nil {
		mmAdd.defaultExpectation.paramPtrs = &ITokenRepositoryMockAddParamPtrs{}
	}
	mmAdd.defaultExpectation.paramPtrs.ctx = &ctx
	mmAdd.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAdd
}

// ExpectKeyParam2 sets up expected param key for ITokenRepository.Add
func (mmAdd *mITokenRepositoryMockAdd) ExpectKeyParam2(key string) *mITokenRepositoryMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("ITokenRepositoryMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &ITokenRepositoryMockAddExpectation{}
	}

	if mmAdd.defaultExpectation.params != nil {
		mmAdd.mock.t.Fatalf("ITokenRepositoryMock.Add mock is already set by Expect")
	}

	if mmAdd.defaultExpectation.paramPtrs == nil {
		mmAdd.defaultExpectation.paramPtrs = &ITokenRepositoryMockAddParamPtrs{}
	}
	mmAdd.defaultExpectation.paramPtrs.key = &key
	mmAdd.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmAdd
}

// ExpectValueParam3 sets up expected param value for ITokenRepository.Add
func (mmAdd *mITokenRepositoryMockAdd) ExpectValueParam3(value string) *mITokenRepositoryMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("ITokenRepositoryMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &ITokenRepositoryMockAddExpectation{}
	}

	if mmAdd.defaultExpectation.params != nil {
		mmAdd.mock.t.Fatalf("ITokenRepositoryMock.Add mock is already set by Expect")
	}

	if mmAdd.defaultExpectation.paramPtrs == nil {
		mmAdd.defaultExpectation.paramPtrs = &ITokenRepositoryMockAddParamPtrs{}
	}
	mmAdd.defaultExpectation.paramPtrs.value = &value
	mmAdd.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmAdd
}

// ExpectExpirationParam4 sets up expected param expiration for ITokenRepository.Add
func (mmAdd *mITokenRepositoryMockAdd) ExpectExpirationParam4(expiration time.Duration) *mITokenRepositoryMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("ITokenRepositoryMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &ITokenRepositoryMockAddExpectation{}
	}

	if mmAdd.defaultExpectation.params != nil {
		mmAdd.mock.t.Fatalf("ITokenRepositoryMock.Add mock is already set by Expect")
	}

	if mmAdd.defaultExpectation.paramPtrs == nil {
		mmAdd.defaultExpectation.paramPtrs = &ITokenRepositoryMockAddParamPtrs{}
	}
	mmAdd.defaultExpectation.paramPtrs.expiration = &expiration
	mmAdd.defaultExpectation.expectationOrigins.originExpiration = minimock.CallerInfo(1)

	return mmAdd
}

// Inspect accepts an inspector function that has same arguments as the ITokenRepository.Add
func (mmAdd *mITokenRepositoryMockAdd) Inspect(f func(ctx context.Context, key string, value string, expiration time.Duration)) *mITokenRepositoryMockAdd {
	if mmAdd.mock.inspectFuncAdd != nil {
		mmAdd.mock.t.Fatalf("Inspect function is already set for ITokenRepositoryMock.Add")
	}

	mmAdd.mock.inspectFuncAdd = f

	return mmAdd
}

// Return sets up results that will be returned by ITokenRepository.Add
func (mmAdd *mITokenRepositoryMockAdd) Return(err error) *ITokenRepositoryMock {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("ITokenRepositoryMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &ITokenRepositoryMockAddExpectation{mock: mmAdd.mock}
	}
	mmAdd.defaultExpectation.results = &ITokenRepositoryMockAddResults{err}
	mmAdd.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAdd.mock
}

// Set uses given function f to mock the ITokenRepository.Add method
func (mmAdd *mITokenRepositoryMockAdd) Set(f func(ctx context.Context, key string, value string, expiration time.Duration) (err error)) *ITokenRepositoryMock {
	if mmAdd.defaultExpectation != nil {
		mmAdd.mock.t.Fatalf("Default expectation is already set for the ITokenRepository.Add method")
	}

	if len(mmAdd.expectations) > 0 {
		mmAdd.mock.t.Fatalf("Some expectations are already set for the ITokenRepository.Add method")
	}

	mmAdd.mock.funcAdd = f
	mmAdd.mock.funcAddOrigin = minimock.CallerInfo(1)
	return mmAdd.mock
}

// When sets expectation for the ITokenRepository.Add which will trigger the result defined by the following
// Then helper
func (mmAdd *mITokenRepositoryMockAdd) When(ctx context.Context, key string, value string, expiration time.Duration) *ITokenRepositoryMockAddExpectation {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("ITokenRepositoryMock.Add mock is already set by Set")
	}

	expectation := &ITokenRepositoryMockAddExpectation{
		mock:               mmAdd.mock,
		params:             &ITokenRepositoryMockAddParams{ctx, key, value, expiration},
		expectationOrigins: ITokenRepositoryMockAddExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAdd.expectations = append(mmAdd.expectations, expectation)
	return expectation
}

// Then sets up ITokenRepository.Add return parameters for the expectation previously defined by the When method
func (e *ITokenRepositoryMockAddExpectation) Then(err error) *ITokenRepositoryMock {
	e.results = &ITokenRepositoryMockAddResults{err}
	return e.mock
}

// Times sets number of times ITokenRepository.Add should be invoked
func (mmAdd *mITokenRepositoryMockAdd) Times(n uint64) *mITokenRepositoryMockAdd {
	if n == 0 {
		mmAdd.mock.t.Fatalf("Times of ITokenRepositoryMock.Add mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAdd.expectedInvocations, n)
	mmAdd.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAdd
}

func (mmAdd *mITokenRepositoryMockAdd) invocationsDone() bool {
	if len(mmAdd.expectations) == 0 && mmAdd.defaultExpectation == nil && mmAdd.mock.funcAdd == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAdd.mock.afterAddCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAdd.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Add implements mm_repository.ITokenRepository
func (mmAdd *ITokenRepositoryMock) Add(ctx context.Context, key string, value string, expiration time.Duration) (err error) {
	mm_atomic.AddUint64(&mmAdd.beforeAddCounter, 1)
	defer mm_atomic.AddUint64(&mmAdd.afterAddCounter, 1)

	mmAdd.t.Helper()

	if mmAdd.inspectFuncAdd != nil {
		mmAdd.inspectFuncAdd(ctx, key, value, expiration)
	}

	mm_params := ITokenRepositoryMockAddParams{ctx, key, value, expiration}

	// Record call args
	mmAdd.AddMock.mutex.Lock()
	mmAdd.AddMock.callArgs = append(mmAdd.AddMock.callArgs, &mm_params)
	mmAdd.AddMock.mutex.Unlock()

	for _, e := range mmAdd.AddMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAdd.AddMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAdd.AddMock.defaultExpectation.Counter, 1)
		mm_want := mmAdd.AddMock.defaultExpectation.params
		mm_want_ptrs := mmAdd.AddMock.defaultExpectation.paramPtrs

		mm_got := ITokenRepositoryMockAddParams{ctx, key, value, expiration}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAdd.t.Errorf("ITokenRepositoryMock.Add got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAdd.AddMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmAdd.t.Errorf("ITokenRepositoryMock.Add got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAdd.AddMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmAdd.t.Errorf("ITokenRepositoryMock.Add got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAdd.AddMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

			if mm_want_ptrs.expiration != nil && !minimock.Equal(*mm_want_ptrs.expiration, mm_got.expiration) {
				mmAdd.t.Errorf("ITokenRepositoryMock.Add got unexpected parameter expiration, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAdd.AddMock.defaultExpectation.expectationOrigins.originExpiration, *mm_want_ptrs.expiration, mm_got.expiration, minimock.Diff(*mm_want_ptrs.expiration, mm_got.expiration))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAdd.t.Errorf("ITokenRepositoryMock.Add got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAdd.AddMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAdd.AddMock.defaultExpectation.results
		if mm_results == nil {
			mmAdd.t.Fatal("No results are set for the ITokenRepositoryMock.Add")
		}
		return (*mm_results).err
	}
	if mmAdd.funcAdd != nil {
		return mmAdd.funcAdd(ctx, key, value, expiration)
	}
	mmAdd.t.Fatalf("Unexpected call to ITokenRepositoryMock.Add. %v %v %v %v", ctx, key, value, expiration)
	return
}

// AddAfterCounter returns a count of finished ITokenRepositoryMock.Add invocations
func (mmAdd *ITokenRepositoryMock) AddAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAdd.afterAddCounter)
}

// AddBeforeCounter returns a count of ITokenRepositoryMock.Add invocations
func (mmAdd *ITokenRepositoryMock) AddBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAdd.beforeAddCounter)
}

// Calls returns a list of arguments used in each call to ITokenRepositoryMock.Add.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAdd *mITokenRepositoryMockAdd) Calls() []*ITokenRepositoryMockAddParams {
	mmAdd.mutex.RLock()

	argCopy := make([]*ITokenRepositoryMockAddParams, len(mmAdd.callArgs))
	copy(argCopy, mmAdd.callArgs)

	mmAdd.mutex.RUnlock()

	return argCopy
}

// MinimockAddDone returns true if the count of the Add invocations corresponds
// the number of defined expectations
func (m *ITokenRepositoryMock) MinimockAddDone() bool {
	if m.AddMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddMock.invocationsDone()
}

// MinimockAddInspect logs each unmet expectation
func (m *ITokenRepositoryMock) MinimockAddInspect() {
	for _, e := range m.AddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ITokenRepositoryMock.Add at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddCounter := mm_atomic.LoadUint64(&m.afterAddCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddMock.defaultExpectation != nil && afterAddCounter < 1 {
		if m.AddMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ITokenRepositoryMock.Add at\n%s", m.AddMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ITokenRepositoryMock.Add at\n%s with params: %#v", m.AddMock.defaultExpectation.expectationOrigins.origin, *m.AddMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAdd != nil && afterAddCounter < 1 {
		m.t.Errorf("Expected call to ITokenRepositoryMock.Add at\n%s", m.funcAddOrigin)
	}

	if !m.AddMock.invocationsDone() && afterAddCounter > 0 {
		m.t.Errorf("Expected %d calls to ITokenRepositoryMock.Add at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddMock.expectedInvocations), m.AddMock.expectedInvocationsOrigin, afterAddCounter)
	}
}

type mITokenRepositoryMockDelete struct {
	optional           bool
	mock               *ITokenRepositoryMock
	defaultExpectation *ITokenRepositoryMockDeleteExpectation
	expectations       []*ITokenRepositoryMockDeleteExpectation

	callArgs []*ITokenRepositoryMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ITokenRepositoryMockDeleteExpectation specifies expectation struct of the ITokenRepository.Delete
type ITokenRepositoryMockDeleteExpectation struct {
	mock               *ITokenRepositoryMock
	params             *ITokenRepositoryMockDeleteParams
	paramPtrs          *ITokenRepositoryMockDeleteParamPtrs
	expectationOrigins ITokenRepositoryMockDeleteExpectationOrigins
	results            *ITokenRepositoryMockDeleteResults
	returnOrigin       string
	Counter            uint64
}

// ITokenRepositoryMockDeleteParams contains parameters of the ITokenRepository.Delete
type ITokenRepositoryMockDeleteParams struct {
	ctx  context.Context
	keys []string
}

// ITokenRepositoryMockDeleteParamPtrs contains pointers to parameters of the ITokenRepository.Delete
type ITokenRepositoryMockDeleteParamPtrs struct {
	ctx  *context.Context
	keys *[]string
}

// ITokenRepositoryMockDeleteResults contains results of the ITokenRepository.Delete
type ITokenRepositoryMockDeleteResults struct {
	err error
}

// ITokenRepositoryMockDeleteOrigins contains origins of expectations of the ITokenRepository.Delete
type ITokenRepositoryMockDeleteExpectationOrigins struct {
	origin     string
	originCtx  string
	originKeys string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mITokenRepositoryMockDelete) Optional() *mITokenRepositoryMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for ITokenRepository.Delete
func (mmDelete *mITokenRepositoryMockDelete) Expect(ctx context.Context, keys ...string) *mITokenRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ITokenRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ITokenRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("ITokenRepositoryMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &ITokenRepositoryMockDeleteParams{ctx, keys}
	mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for ITokenRepository.Delete
func (mmDelete *mITokenRepositoryMockDelete) ExpectCtxParam1(ctx context.Context) *mITokenRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ITokenRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ITokenRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("ITokenRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &ITokenRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx
	mmDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectKeysParam2 sets up expected param keys for ITokenRepository.Delete
func (mmDelete *mITokenRepositoryMockDelete) ExpectKeysParam2(keys ...string) *mITokenRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ITokenRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ITokenRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("ITokenRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &ITokenRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.keys = &keys
	mmDelete.defaultExpectation.expectationOrigins.originKeys = minimock.CallerInfo(1)

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the ITokenRepository.Delete
func (mmDelete *mITokenRepositoryMockDelete) Inspect(f func(ctx context.Context, keys ...string)) *mITokenRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for ITokenRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by ITokenRepository.Delete
func (mmDelete *mITokenRepositoryMockDelete) Return(err error) *ITokenRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ITokenRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ITokenRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &ITokenRepositoryMockDeleteResults{err}
	mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// Set uses given function f to mock the ITokenRepository.Delete method
func (mmDelete *mITokenRepositoryMockDelete) Set(f func(ctx context.Context, keys ...string) (err error)) *ITokenRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the ITokenRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the ITokenRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// When sets expectation for the ITokenRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mITokenRepositoryMockDelete) When(ctx context.Context, keys ...string) *ITokenRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ITokenRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &ITokenRepositoryMockDeleteExpectation{
		mock:               mmDelete.mock,
		params:             &ITokenRepositoryMockDeleteParams{ctx, keys},
		expectationOrigins: ITokenRepositoryMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up ITokenRepository.Delete return parameters for the expectation previously defined by the When method
func (e *ITokenRepositoryMockDeleteExpectation) Then(err error) *ITokenRepositoryMock {
	e.results = &ITokenRepositoryMockDeleteResults{err}
	return e.mock
}

// Times sets number of times ITokenRepository.Delete should be invoked
func (mmDelete *mITokenRepositoryMockDelete) Times(n uint64) *mITokenRepositoryMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of ITokenRepositoryMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelete
}

func (mmDelete *mITokenRepositoryMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements mm_repository.ITokenRepository
func (mmDelete *ITokenRepositoryMock) Delete(ctx context.Context, keys ...string) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	mmDelete.t.Helper()

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, keys...)
	}

	mm_params := ITokenRepositoryMockDeleteParams{ctx, keys}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := ITokenRepositoryMockDeleteParams{ctx, keys}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("ITokenRepositoryMock.Delete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.keys != nil && !minimock.Equal(*mm_want_ptrs.keys, mm_got.keys) {
				mmDelete.t.Errorf("ITokenRepositoryMock.Delete got unexpected parameter keys, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originKeys, *mm_want_ptrs.keys, mm_got.keys, minimock.Diff(*mm_want_ptrs.keys, mm_got.keys))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("ITokenRepositoryMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the ITokenRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, keys...)
	}
	mmDelete.t.Fatalf("Unexpected call to ITokenRepositoryMock.Delete. %v %v", ctx, keys)
	return
}

// DeleteAfterCounter returns a count of finished ITokenRepositoryMock.Delete invocations
func (mmDelete *ITokenRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of ITokenRepositoryMock.Delete invocations
func (mmDelete *ITokenRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to ITokenRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mITokenRepositoryMockDelete) Calls() []*ITokenRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*ITokenRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *ITokenRepositoryMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *ITokenRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ITokenRepositoryMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ITokenRepositoryMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ITokenRepositoryMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Errorf("Expected call to ITokenRepositoryMock.Delete at\n%s", m.funcDeleteOrigin)
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to ITokenRepositoryMock.Delete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
	}
}

type mITokenRepositoryMockGet struct {
	optional           bool
	mock               *ITokenRepositoryMock
	defaultExpectation *ITokenRepositoryMockGetExpectation
	expectations       []*ITokenRepositoryMockGetExpectation

	callArgs []*ITokenRepositoryMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ITokenRepositoryMockGetExpectation specifies expectation struct of the ITokenRepository.Get
type ITokenRepositoryMockGetExpectation struct {
	mock               *ITokenRepositoryMock
	params             *ITokenRepositoryMockGetParams
	paramPtrs          *ITokenRepositoryMockGetParamPtrs
	expectationOrigins ITokenRepositoryMockGetExpectationOrigins
	results            *ITokenRepositoryMockGetResults
	returnOrigin       string
	Counter            uint64
}

// ITokenRepositoryMockGetParams contains parameters of the ITokenRepository.Get
type ITokenRepositoryMockGetParams struct {
	ctx context.Context
	key string
}

// ITokenRepositoryMockGetParamPtrs contains pointers to parameters of the ITokenRepository.Get
type ITokenRepositoryMockGetParamPtrs struct {
	ctx *context.Context
	key *string
}

// ITokenRepositoryMockGetResults contains results of the ITokenRepository.Get
type ITokenRepositoryMockGetResults struct {
	s1  string
	err error
}

// ITokenRepositoryMockGetOrigins contains origins of expectations of the ITokenRepository.Get
type ITokenRepositoryMockGetExpectationOrigins struct {
	origin    string
	originCtx string
	originKey string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mITokenRepositoryMockGet) Optional() *mITokenRepositoryMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for ITokenRepository.Get
func (mmGet *mITokenRepositoryMockGet) Expect(ctx context.Context, key string) *mITokenRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ITokenRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &ITokenRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("ITokenRepositoryMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &ITokenRepositoryMockGetParams{ctx, key}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for ITokenRepository.Get
func (mmGet *mITokenRepositoryMockGet) ExpectCtxParam1(ctx context.Context) *mITokenRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ITokenRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &ITokenRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("ITokenRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &ITokenRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx
	mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGet
}

// ExpectKeyParam2 sets up expected param key for ITokenRepository.Get
func (mmGet *mITokenRepositoryMockGet) ExpectKeyParam2(key string) *mITokenRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ITokenRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &ITokenRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("ITokenRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &ITokenRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.key = &key
	mmGet.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the ITokenRepository.Get
func (mmGet *mITokenRepositoryMockGet) Inspect(f func(ctx context.Context, key string)) *mITokenRepositoryMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for ITokenRepositoryMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by ITokenRepository.Get
func (mmGet *mITokenRepositoryMockGet) Return(s1 string, err error) *ITokenRepositoryMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ITokenRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &ITokenRepositoryMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &ITokenRepositoryMockGetResults{s1, err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the ITokenRepository.Get method
func (mmGet *mITokenRepositoryMockGet) Set(f func(ctx context.Context, key string) (s1 string, err error)) *ITokenRepositoryMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the ITokenRepository.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the ITokenRepository.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the ITokenRepository.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mITokenRepositoryMockGet) When(ctx context.Context, key string) *ITokenRepositoryMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ITokenRepositoryMock.Get mock is already set by Set")
	}

	expectation := &ITokenRepositoryMockGetExpectation{
		mock:               mmGet.mock,
		params:             &ITokenRepositoryMockGetParams{ctx, key},
		expectationOrigins: ITokenRepositoryMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up ITokenRepository.Get return parameters for the expectation previously defined by the When method
func (e *ITokenRepositoryMockGetExpectation) Then(s1 string, err error) *ITokenRepositoryMock {
	e.results = &ITokenRepositoryMockGetResults{s1, err}
	return e.mock
}

// Times sets number of times ITokenRepository.Get should be invoked
func (mmGet *mITokenRepositoryMockGet) Times(n uint64) *mITokenRepositoryMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of ITokenRepositoryMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mITokenRepositoryMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_repository.ITokenRepository
func (mmGet *ITokenRepositoryMock) Get(ctx context.Context, key string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, key)
	}

	mm_params := ITokenRepositoryMockGetParams{ctx, key}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := ITokenRepositoryMockGetParams{ctx, key}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("ITokenRepositoryMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmGet.t.Errorf("ITokenRepositoryMock.Get got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("ITokenRepositoryMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the ITokenRepositoryMock.Get")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, key)
	}
	mmGet.t.Fatalf("Unexpected call to ITokenRepositoryMock.Get. %v %v", ctx, key)
	return
}

// GetAfterCounter returns a count of finished ITokenRepositoryMock.Get invocations
func (mmGet *ITokenRepositoryMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of ITokenRepositoryMock.Get invocations
func (mmGet *ITokenRepositoryMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to ITokenRepositoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mITokenRepositoryMockGet) Calls() []*ITokenRepositoryMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*ITokenRepositoryMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *ITokenRepositoryMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *ITokenRepositoryMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ITokenRepositoryMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ITokenRepositoryMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ITokenRepositoryMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to ITokenRepositoryMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to ITokenRepositoryMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mITokenRepositoryMockList struct {
	optional           bool
	mock               *ITokenRepositoryMock
	defaultExpectation *ITokenRepositoryMockListExpectation
	expectations       []*ITokenRepositoryMockListExpectation

	callArgs []*ITokenRepositoryMockListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ITokenRepositoryMockListExpectation specifies expectation struct of the ITokenRepository.List
type ITokenRepositoryMockListExpectation struct {
	mock               *ITokenRepositoryMock
	params             *ITokenRepositoryMockListParams
	paramPtrs          *ITokenRepositoryMockListParamPtrs
	expectationOrigins ITokenRepositoryMockListExpectationOrigins
	results            *ITokenRepositoryMockListResults
	returnOrigin       string
	Counter            uint64
}

// ITokenRepositoryMockListParams contains parameters of the ITokenRepository.List
type ITokenRepositoryMockListParams struct {
	ctx context.Context
	key string
}

// ITokenRepositoryMockListParamPtrs contains pointers to parameters of the ITokenRepository.List
type ITokenRepositoryMockListParamPtrs struct {
	ctx *context.Context
	key *string
}

// ITokenRepositoryMockListResults contains results of the ITokenRepository.List
type ITokenRepositoryMockListResults struct {
	sa1 []string
	err error
}

// ITokenRepositoryMockListOrigins contains origins of expectations of the ITokenRepository.List
type ITokenRepositoryMockListExpectationOrigins struct {
	origin    string
	originCtx string
	originKey string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmList *mITokenRepositoryMockList) Optional() *mITokenRepositoryMockList {
	mmList.optional = true
	return mmList
}

// Expect sets up expected params for ITokenRepository.List
func (mmList *mITokenRepositoryMockList) Expect(ctx context.Context, key string) *mITokenRepositoryMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("ITokenRepositoryMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &ITokenRepositoryMockListExpectation{}
	}

	if mmList.defaultExpectation.paramPtrs != nil {
		mmList.mock.t.Fatalf("ITokenRepositoryMock.List mock is already set by ExpectParams functions")
	}

	mmList.defaultExpectation.params = &ITokenRepositoryMockListParams{ctx, key}
	mmList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmList.expectations {
		if minimock.Equal(e.params, mmList.defaultExpectation.params) {
			mmList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmList.defaultExpectation.params)
		}
	}

	return mmList
}

// ExpectCtxParam1 sets up expected param ctx for ITokenRepository.List
func (mmList *mITokenRepositoryMockList) ExpectCtxParam1(ctx context.Context) *mITokenRepositoryMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("ITokenRepositoryMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &ITokenRepositoryMockListExpectation{}
	}

	if mmList.defaultExpectation.params != nil {
		mmList.mock.t.Fatalf("ITokenRepositoryMock.List mock is already set by Expect")
	}

	if mmList.defaultExpectation.paramPtrs == nil {
		mmList.defaultExpectation.paramPtrs = &ITokenRepositoryMockListParamPtrs{}
	}
	mmList.defaultExpectation.paramPtrs.ctx = &ctx
	mmList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmList
}

// ExpectKeyParam2 sets up expected param key for ITokenRepository.List
func (mmList *mITokenRepositoryMockList) ExpectKeyParam2(key string) *mITokenRepositoryMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("ITokenRepositoryMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &ITokenRepositoryMockListExpectation{}
	}

	if mmList.defaultExpectation.params != nil {
		mmList.mock.t.Fatalf("ITokenRepositoryMock.List mock is already set by Expect")
	}

	if mmList.defaultExpectation.paramPtrs == nil {
		mmList.defaultExpectation.paramPtrs = &ITokenRepositoryMockListParamPtrs{}
	}
	mmList.defaultExpectation.paramPtrs.key = &key
	mmList.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmList
}

// Inspect accepts an inspector function that has same arguments as the ITokenRepository.List
func (mmList *mITokenRepositoryMockList) Inspect(f func(ctx context.Context, key string)) *mITokenRepositoryMockList {
	if mmList.mock.inspectFuncList != nil {
		mmList.mock.t.Fatalf("Inspect function is already set for ITokenRepositoryMock.List")
	}

	mmList.mock.inspectFuncList = f

	return mmList
}

// Return sets up results that will be returned by ITokenRepository.List
func (mmList *mITokenRepositoryMockList) Return(sa1 []string, err error) *ITokenRepositoryMock {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("ITokenRepositoryMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &ITokenRepositoryMockListExpectation{mock: mmList.mock}
	}
	mmList.defaultExpectation.results = &ITokenRepositoryMockListResults{sa1, err}
	mmList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmList.mock
}

// Set uses given function f to mock the ITokenRepository.List method
func (mmList *mITokenRepositoryMockList) Set(f func(ctx context.Context, key string) (sa1 []string, err error)) *ITokenRepositoryMock {
	if mmList.defaultExpectation != nil {
		mmList.mock.t.Fatalf("Default expectation is already set for the ITokenRepository.List method")
	}

	if len(mmList.expectations) > 0 {
		mmList.mock.t.Fatalf("Some expectations are already set for the ITokenRepository.List method")
	}

	mmList.mock.funcList = f
	mmList.mock.funcListOrigin = minimock.CallerInfo(1)
	return mmList.mock
}

// When sets expectation for the ITokenRepository.List which will trigger the result defined by the following
// Then helper
func (mmList *mITokenRepositoryMockList) When(ctx context.Context, key string) *ITokenRepositoryMockListExpectation {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("ITokenRepositoryMock.List mock is already set by Set")
	}

	expectation := &ITokenRepositoryMockListExpectation{
		mock:               mmList.mock,
		params:             &ITokenRepositoryMockListParams{ctx, key},
		expectationOrigins: ITokenRepositoryMockListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmList.expectations = append(mmList.expectations, expectation)
	return expectation
}

// Then sets up ITokenRepository.List return parameters for the expectation previously defined by the When method
func (e *ITokenRepositoryMockListExpectation) Then(sa1 []string, err error) *ITokenRepositoryMock {
	e.results = &ITokenRepositoryMockListResults{sa1, err}
	return e.mock
}

// Times sets number of times ITokenRepository.List should be invoked
func (mmList *mITokenRepositoryMockList) Times(n uint64) *mITokenRepositoryMockList {
	if n == 0 {
		mmList.mock.t.Fatalf("Times of ITokenRepositoryMock.List mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmList.expectedInvocations, n)
	mmList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmList
}

func (mmList *mITokenRepositoryMockList) invocationsDone() bool {
	if len(mmList.expectations) == 0 && mmList.defaultExpectation == nil && mmList.mock.funcList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmList.mock.afterListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// List implements mm_repository.ITokenRepository
func (mmList *ITokenRepositoryMock) List(ctx context.Context, key string) (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmList.beforeListCounter, 1)
	defer mm_atomic.AddUint64(&mmList.afterListCounter, 1)

	mmList.t.Helper()

	if mmList.inspectFuncList != nil {
		mmList.inspectFuncList(ctx, key)
	}

	mm_params := ITokenRepositoryMockListParams{ctx, key}

	// Record call args
	mmList.ListMock.mutex.Lock()
	mmList.ListMock.callArgs = append(mmList.ListMock.callArgs, &mm_params)
	mmList.ListMock.mutex.Unlock()

	for _, e := range mmList.ListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmList.ListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmList.ListMock.defaultExpectation.Counter, 1)
		mm_want := mmList.ListMock.defaultExpectation.params
		mm_want_ptrs := mmList.ListMock.defaultExpectation.paramPtrs

		mm_got := ITokenRepositoryMockListParams{ctx, key}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmList.t.Errorf("ITokenRepositoryMock.List got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmList.ListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmList.t.Errorf("ITokenRepositoryMock.List got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmList.ListMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmList.t.Errorf("ITokenRepositoryMock.List got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmList.ListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmList.ListMock.defaultExpectation.results
		if mm_results == nil {
			mmList.t.Fatal("No results are set for the ITokenRepositoryMock.List")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmList.funcList != nil {
		return mmList.funcList(ctx, key)
	}
	mmList.t.Fatalf("Unexpected call to ITokenRepositoryMock.List. %v %v", ctx, key)
	return
}

// ListAfterCounter returns a count of finished ITokenRepositoryMock.List invocations
func (mmList *ITokenRepositoryMock) ListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmList.afterListCounter)
}

// ListBeforeCounter returns a count of ITokenRepositoryMock.List invocations
func (mmList *ITokenRepositoryMock) ListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmList.beforeListCounter)
}

// Calls returns a list of arguments used in each call to ITokenRepositoryMock.List.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmList *mITokenRepositoryMockList) Calls() []*ITokenRepositoryMockListParams {
	mmList.mutex.RLock()

	argCopy := make([]*ITokenRepositoryMockListParams, len(mmList.callArgs))
	copy(argCopy, mmList.callArgs)

	mmList.mutex.RUnlock()

	return argCopy
}

// MinimockListDone returns true if the count of the List invocations corresponds
// the number of defined expectations
func (m *ITokenRepositoryMock) MinimockListDone() bool {
	if m.ListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListMock.invocationsDone()
}

// MinimockListInspect logs each unmet expectation
func (m *ITokenRepositoryMock) MinimockListInspect() {
	for _, e := range m.ListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ITokenRepositoryMock.List at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListCounter := mm_atomic.LoadUint64(&m.afterListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListMock.defaultExpectation != nil && afterListCounter < 1 {
		if m.ListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ITokenRepositoryMock.List at\n%s", m.ListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ITokenRepositoryMock.List at\n%s with params: %#v", m.ListMock.defaultExpectation.expectationOrigins.origin, *m.ListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcList != nil && afterListCounter < 1 {
		m.t.Errorf("Expected call to ITokenRepositoryMock.List at\n%s", m.funcListOrigin)
	}

	if !m.ListMock.invocationsDone() && afterListCounter > 0 {
		m.t.Errorf("Expected %d calls to ITokenRepositoryMock.List at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListMock.expectedInvocations), m.ListMock.expectedInvocationsOrigin, afterListCounter)
	}
}

type mITokenRepositoryMockPush struct {
	optional           bool
	mock               *ITokenRepositoryMock
	defaultExpectation *ITokenRepositoryMockPushExpectation
	expectations       []*ITokenRepositoryMockPushExpectation

	callArgs []*ITokenRepositoryMockPushParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ITokenRepositoryMockPushExpectation specifies expectation struct of the ITokenRepository.Push
type ITokenRepositoryMockPushExpectation struct {
	mock               *ITokenRepositoryMock
	params             *ITokenRepositoryMockPushParams
	paramPtrs          *ITokenRepositoryMockPushParamPtrs
	expectationOrigins ITokenRepositoryMockPushExpectationOrigins
	results            *ITokenRepositoryMockPushResults
	returnOrigin       string
	Counter            uint64
}

// ITokenRepositoryMockPushParams contains parameters of the ITokenRepository.Push
type ITokenRepositoryMockPushParams struct {
	ctx    context.Context
	key    string
	values []string
}

// ITokenRepositoryMockPushParamPtrs contains pointers to parameters of the ITokenRepository.Push
type ITokenRepositoryMockPushParamPtrs struct {
	ctx    *context.Context
	key    *string
	values *[]string
}

// ITokenRepositoryMockPushResults contains results of the ITokenRepository.Push
type ITokenRepositoryMockPushResults struct {
	err error
}

// ITokenRepositoryMockPushOrigins contains origins of expectations of the ITokenRepository.Push
type ITokenRepositoryMockPushExpectationOrigins struct {
	origin       string
	originCtx    string
	originKey    string
	originValues string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPush *mITokenRepositoryMockPush) Optional() *mITokenRepositoryMockPush {
	mmPush.optional = true
	return mmPush
}

// Expect sets up expected params for ITokenRepository.Push
func (mmPush *mITokenRepositoryMockPush) Expect(ctx context.Context, key string, values ...string) *mITokenRepositoryMockPush {
	if mmPush.mock.funcPush != nil {
		mmPush.mock.t.Fatalf("ITokenRepositoryMock.Push mock is already set by Set")
	}

	if mmPush.defaultExpectation == nil {
		mmPush.defaultExpectation = &ITokenRepositoryMockPushExpectation{}
	}

	if mmPush.defaultExpectation.paramPtrs != nil {
		mmPush.mock.t.Fatalf("ITokenRepositoryMock.Push mock is already set by ExpectParams functions")
	}

	mmPush.defaultExpectation.params = &ITokenRepositoryMockPushParams{ctx, key, values}
	mmPush.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPush.expectations {
		if minimock.Equal(e.params, mmPush.defaultExpectation.params) {
			mmPush.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPush.defaultExpectation.params)
		}
	}

	return mmPush
}

// ExpectCtxParam1 sets up expected param ctx for ITokenRepository.Push
func (mmPush *mITokenRepositoryMockPush) ExpectCtxParam1(ctx context.Context) *mITokenRepositoryMockPush {
	if mmPush.mock.funcPush != nil {
		mmPush.mock.t.Fatalf("ITokenRepositoryMock.Push mock is already set by Set")
	}

	if mmPush.defaultExpectation == nil {
		mmPush.defaultExpectation = &ITokenRepositoryMockPushExpectation{}
	}

	if mmPush.defaultExpectation.params != nil {
		mmPush.mock.t.Fatalf("ITokenRepositoryMock.Push mock is already set by Expect")
	}

	if mmPush.defaultExpectation.paramPtrs == nil {
		mmPush.defaultExpectation.paramPtrs = &ITokenRepositoryMockPushParamPtrs{}
	}
	mmPush.defaultExpectation.paramPtrs.ctx = &ctx
	mmPush.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPush
}

// ExpectKeyParam2 sets up expected param key for ITokenRepository.Push
func (mmPush *mITokenRepositoryMockPush) ExpectKeyParam2(key string) *mITokenRepositoryMockPush {
	if mmPush.mock.funcPush != nil {
		mmPush.mock.t.Fatalf("ITokenRepositoryMock.Push mock is already set by Set")
	}

	if mmPush.defaultExpectation == nil {
		mmPush.defaultExpectation = &ITokenRepositoryMockPushExpectation{}
	}

	if mmPush.defaultExpectation.params != nil {
		mmPush.mock.t.Fatalf("ITokenRepositoryMock.Push mock is already set by Expect")
	}

	if mmPush.defaultExpectation.paramPtrs == nil {
		mmPush.defaultExpectation.paramPtrs = &ITokenRepositoryMockPushParamPtrs{}
	}
	mmPush.defaultExpectation.paramPtrs.key = &key
	mmPush.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmPush
}

// ExpectValuesParam3 sets up expected param values for ITokenRepository.Push
func (mmPush *mITokenRepositoryMockPush) ExpectValuesParam3(values ...string) *mITokenRepositoryMockPush {
	if mmPush.mock.funcPush != nil {
		mmPush.mock.t.Fatalf("ITokenRepositoryMock.Push mock is already set by Set")
	}

	if mmPush.defaultExpectation == nil {
		mmPush.defaultExpectation = &ITokenRepositoryMockPushExpectation{}
	}

	if mmPush.defaultExpectation.params != nil {
		mmPush.mock.t.Fatalf("ITokenRepositoryMock.Push mock is already set by Expect")
	}

	if mmPush.defaultExpectation.paramPtrs == nil {
		mmPush.defaultExpectation.paramPtrs = &ITokenRepositoryMockPushParamPtrs{}
	}
	mmPush.defaultExpectation.paramPtrs.values = &values
	mmPush.defaultExpectation.expectationOrigins.originValues = minimock.CallerInfo(1)

	return mmPush
}

// Inspect accepts an inspector function that has same arguments as the ITokenRepository.Push
func (mmPush *mITokenRepositoryMockPush) Inspect(f func(ctx context.Context, key string, values ...string)) *mITokenRepositoryMockPush {
	if mmPush.mock.inspectFuncPush != nil {
		mmPush.mock.t.Fatalf("Inspect function is already set for ITokenRepositoryMock.Push")
	}

	mmPush.mock.inspectFuncPush = f

	return mmPush
}

// Return sets up results that will be returned by ITokenRepository.Push
func (mmPush *mITokenRepositoryMockPush) Return(err error) *ITokenRepositoryMock {
	if mmPush.mock.funcPush != nil {
		mmPush.mock.t.Fatalf("ITokenRepositoryMock.Push mock is already set by Set")
	}

	if mmPush.defaultExpectation == nil {
		mmPush.defaultExpectation = &ITokenRepositoryMockPushExpectation{mock: mmPush.mock}
	}
	mmPush.defaultExpectation.results = &ITokenRepositoryMockPushResults{err}
	mmPush.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPush.mock
}

// Set uses given function f to mock the ITokenRepository.Push method
func (mmPush *mITokenRepositoryMockPush) Set(f func(ctx context.Context, key string, values ...string) (err error)) *ITokenRepositoryMock {
	if mmPush.defaultExpectation != nil {
		mmPush.mock.t.Fatalf("Default expectation is already set for the ITokenRepository.Push method")
	}

	if len(mmPush.expectations) > 0 {
		mmPush.mock.t.Fatalf("Some expectations are already set for the ITokenRepository.Push method")
	}

	mmPush.mock.funcPush = f
	mmPush.mock.funcPushOrigin = minimock.CallerInfo(1)
	return mmPush.mock
}

// When sets expectation for the ITokenRepository.Push which will trigger the result defined by the following
// Then helper
func (mmPush *mITokenRepositoryMockPush) When(ctx context.Context, key string, values ...string) *ITokenRepositoryMockPushExpectation {
	if mmPush.mock.funcPush != nil {
		mmPush.mock.t.Fatalf("ITokenRepositoryMock.Push mock is already set by Set")
	}

	expectation := &ITokenRepositoryMockPushExpectation{
		mock:               mmPush.mock,
		params:             &ITokenRepositoryMockPushParams{ctx, key, values},
		expectationOrigins: ITokenRepositoryMockPushExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPush.expectations = append(mmPush.expectations, expectation)
	return expectation
}

// Then sets up ITokenRepository.Push return parameters for the expectation previously defined by the When method
func (e *ITokenRepositoryMockPushExpectation) Then(err error) *ITokenRepositoryMock {
	e.results = &ITokenRepositoryMockPushResults{err}
	return e.mock
}

// Times sets number of times ITokenRepository.Push should be invoked
func (mmPush *mITokenRepositoryMockPush) Times(n uint64) *mITokenRepositoryMockPush {
	if n == 0 {
		mmPush.mock.t.Fatalf("Times of ITokenRepositoryMock.Push mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPush.expectedInvocations, n)
	mmPush.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPush
}

func (mmPush *mITokenRepositoryMockPush) invocationsDone() bool {
	if len(mmPush.expectations) == 0 && mmPush.defaultExpectation == nil && mmPush.mock.funcPush == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPush.mock.afterPushCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPush.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Push implements mm_repository.ITokenRepository
func (mmPush *ITokenRepositoryMock) Push(ctx context.Context, key string, values ...string) (err error) {
	mm_atomic.AddUint64(&mmPush.beforePushCounter, 1)
	defer mm_atomic.AddUint64(&mmPush.afterPushCounter, 1)

	mmPush.t.Helper()

	if mmPush.inspectFuncPush != nil {
		mmPush.inspectFuncPush(ctx, key, values...)
	}

	mm_params := ITokenRepositoryMockPushParams{ctx, key, values}

	// Record call args
	mmPush.PushMock.mutex.Lock()
	mmPush.PushMock.callArgs = append(mmPush.PushMock.callArgs, &mm_params)
	mmPush.PushMock.mutex.Unlock()

	for _, e := range mmPush.PushMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPush.PushMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPush.PushMock.defaultExpectation.Counter, 1)
		mm_want := mmPush.PushMock.defaultExpectation.params
		mm_want_ptrs := mmPush.PushMock.defaultExpectation.paramPtrs

		mm_got := ITokenRepositoryMockPushParams{ctx, key, values}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPush.t.Errorf("ITokenRepositoryMock.Push got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPush.PushMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmPush.t.Errorf("ITokenRepositoryMock.Push got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPush.PushMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.values != nil && !minimock.Equal(*mm_want_ptrs.values, mm_got.values) {
				mmPush.t.Errorf("ITokenRepositoryMock.Push got unexpected parameter values, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPush.PushMock.defaultExpectation.expectationOrigins.originValues, *mm_want_ptrs.values, mm_got.values, minimock.Diff(*mm_want_ptrs.values, mm_got.values))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPush.t.Errorf("ITokenRepositoryMock.Push got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPush.PushMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPush.PushMock.defaultExpectation.results
		if mm_results == nil {
			mmPush.t.Fatal("No results are set for the ITokenRepositoryMock.Push")
		}
		return (*mm_results).err
	}
	if mmPush.funcPush != nil {
		return mmPush.funcPush(ctx, key, values...)
	}
	mmPush.t.Fatalf("Unexpected call to ITokenRepositoryMock.Push. %v %v %v", ctx, key, values)
	return
}

// PushAfterCounter returns a count of finished ITokenRepositoryMock.Push invocations
func (mmPush *ITokenRepositoryMock) PushAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPush.afterPushCounter)
}

// PushBeforeCounter returns a count of ITokenRepositoryMock.Push invocations
func (mmPush *ITokenRepositoryMock) PushBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPush.beforePushCounter)
}

// Calls returns a list of arguments used in each call to ITokenRepositoryMock.Push.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPush *mITokenRepositoryMockPush) Calls() []*ITokenRepositoryMockPushParams {
	mmPush.mutex.RLock()

	argCopy := make([]*ITokenRepositoryMockPushParams, len(mmPush.callArgs))
	copy(argCopy, mmPush.callArgs)

	mmPush.mutex.RUnlock()

	return argCopy
}

// MinimockPushDone returns true if the count of the Push invocations corresponds
// the number of defined expectations
func (m *ITokenRepositoryMock) MinimockPushDone() bool {
	if m.PushMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PushMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PushMock.invocationsDone()
}

// MinimockPushInspect logs each unmet expectation
func (m *ITokenRepositoryMock) MinimockPushInspect() {
	for _, e := range m.PushMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ITokenRepositoryMock.Push at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPushCounter := mm_atomic.LoadUint64(&m.afterPushCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PushMock.defaultExpectation != nil && afterPushCounter < 1 {
		if m.PushMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ITokenRepositoryMock.Push at\n%s", m.PushMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ITokenRepositoryMock.Push at\n%s with params: %#v", m.PushMock.defaultExpectation.expectationOrigins.origin, *m.PushMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPush != nil && afterPushCounter < 1 {
		m.t.Errorf("Expected call to ITokenRepositoryMock.Push at\n%s", m.funcPushOrigin)
	}

	if !m.PushMock.invocationsDone() && afterPushCounter > 0 {
		m.t.Errorf("Expected %d calls to ITokenRepositoryMock.Push at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PushMock.expectedInvocations), m.PushMock.expectedInvocationsOrigin, afterPushCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ITokenRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddInspect()

			m.MinimockDeleteInspect()

			m.MinimockGetInspect()

			m.MinimockListInspect()

			m.MinimockPushInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ITokenRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ITokenRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDone() &&
		m.MinimockListDone() &&
		m.MinimockPushDone()
}
