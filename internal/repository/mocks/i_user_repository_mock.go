// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/maisiq/go-auth-service/internal/repository.IUserRepository -o i_user_repository_mock.go -n IUserRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/maisiq/go-auth-service/internal/domain"
)

// IUserRepositoryMock implements mm_repository.IUserRepository
type IUserRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAdd          func(ctx context.Context, user domain.User) (err error)
	funcAddOrigin    string
	inspectFuncAdd   func(ctx context.Context, user domain.User)
	afterAddCounter  uint64
	beforeAddCounter uint64
	AddMock          mIUserRepositoryMockAdd

	funcAddLog          func(ctx context.Context, log domain.UserLog) (err error)
	funcAddLogOrigin    string
	inspectFuncAddLog   func(ctx context.Context, log domain.UserLog)
	afterAddLogCounter  uint64
	beforeAddLogCounter uint64
	AddLogMock          mIUserRepositoryMockAddLog

	funcGetByEmail          func(ctx context.Context, email string) (u1 domain.User, err error)
	funcGetByEmailOrigin    string
	inspectFuncGetByEmail   func(ctx context.Context, email string)
	afterGetByEmailCounter  uint64
	beforeGetByEmailCounter uint64
	GetByEmailMock          mIUserRepositoryMockGetByEmail

	funcLogs          func(ctx context.Context, email string) (ua1 []domain.UserLog, err error)
	funcLogsOrigin    string
	inspectFuncLogs   func(ctx context.Context, email string)
	afterLogsCounter  uint64
	beforeLogsCounter uint64
	LogsMock          mIUserRepositoryMockLogs

	funcUpdate          func(ctx context.Context, user domain.User) (err error)
	funcUpdateOrigin    string
	inspectFuncUpdate   func(ctx context.Context, user domain.User)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mIUserRepositoryMockUpdate
}

// NewIUserRepositoryMock returns a mock for mm_repository.IUserRepository
func NewIUserRepositoryMock(t minimock.Tester) *IUserRepositoryMock {
	m := &IUserRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddMock = mIUserRepositoryMockAdd{mock: m}
	m.AddMock.callArgs = []*IUserRepositoryMockAddParams{}

	m.AddLogMock = mIUserRepositoryMockAddLog{mock: m}
	m.AddLogMock.callArgs = []*IUserRepositoryMockAddLogParams{}

	m.GetByEmailMock = mIUserRepositoryMockGetByEmail{mock: m}
	m.GetByEmailMock.callArgs = []*IUserRepositoryMockGetByEmailParams{}

	m.LogsMock = mIUserRepositoryMockLogs{mock: m}
	m.LogsMock.callArgs = []*IUserRepositoryMockLogsParams{}

	m.UpdateMock = mIUserRepositoryMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*IUserRepositoryMockUpdateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mIUserRepositoryMockAdd struct {
	optional           bool
	mock               *IUserRepositoryMock
	defaultExpectation *IUserRepositoryMockAddExpectation
	expectations       []*IUserRepositoryMockAddExpectation

	callArgs []*IUserRepositoryMockAddParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IUserRepositoryMockAddExpectation specifies expectation struct of the IUserRepository.Add
type IUserRepositoryMockAddExpectation struct {
	mock               *IUserRepositoryMock
	params             *IUserRepositoryMockAddParams
	paramPtrs          *IUserRepositoryMockAddParamPtrs
	expectationOrigins IUserRepositoryMockAddExpectationOrigins
	results            *IUserRepositoryMockAddResults
	returnOrigin       string
	Counter            uint64
}

// IUserRepositoryMockAddParams contains parameters of the IUserRepository.Add
type IUserRepositoryMockAddParams struct {
	ctx  context.Context
	user domain.User
}

// IUserRepositoryMockAddParamPtrs contains pointers to parameters of the IUserRepository.Add
type IUserRepositoryMockAddParamPtrs struct {
	ctx  *context.Context
	user *domain.User
}

// IUserRepositoryMockAddResults contains results of the IUserRepository.Add
type IUserRepositoryMockAddResults struct {
	err error
}

// IUserRepositoryMockAddOrigins contains origins of expectations of the IUserRepository.Add
type IUserRepositoryMockAddExpectationOrigins struct {
	origin     string
	originCtx  string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAdd *mIUserRepositoryMockAdd) Optional() *mIUserRepositoryMockAdd {
	mmAdd.optional = true
	return mmAdd
}

// Expect sets up expected params for IUserRepository.Add
func (mmAdd *mIUserRepositoryMockAdd) Expect(ctx context.Context, user domain.User) *mIUserRepositoryMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("IUserRepositoryMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &IUserRepositoryMockAddExpectation{}
	}

	if mmAdd.defaultExpectation.paramPtrs != nil {
		mmAdd.mock.t.Fatalf("IUserRepositoryMock.Add mock is already set by ExpectParams functions")
	}

	mmAdd.defaultExpectation.params = &IUserRepositoryMockAddParams{ctx, user}
	mmAdd.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAdd.expectations {
		if minimock.Equal(e.params, mmAdd.defaultExpectation.params) {
			mmAdd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAdd.defaultExpectation.params)
		}
	}

	return mmAdd
}

// ExpectCtxParam1 sets up expected param ctx for IUserRepository.Add
func (mmAdd *mIUserRepositoryMockAdd) ExpectCtxParam1(ctx context.Context) *mIUserRepositoryMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("IUserRepositoryMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &IUserRepositoryMockAddExpectation{}
	}

	if mmAdd.defaultExpectation.params != nil {
		mmAdd.mock.t.Fatalf("IUserRepositoryMock.Add mock is already set by Expect")
	}

	if mmAdd.defaultExpectation.paramPtrs == nil {
		mmAdd.defaultExpectation.paramPtrs = &IUserRepositoryMockAddParamPtrs{}
	}
	mmAdd.defaultExpectation.paramPtrs.ctx = &ctx
	mmAdd.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAdd
}

// ExpectUserParam2 sets up expected param user for IUserRepository.Add
func (mmAdd *mIUserRepositoryMockAdd) ExpectUserParam2(user domain.User) *mIUserRepositoryMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("IUserRepositoryMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &IUserRepositoryMockAddExpectation{}
	}

	if mmAdd.defaultExpectation.params != nil {
		mmAdd.mock.t.Fatalf("IUserRepositoryMock.Add mock is already set by Expect")
	}

	if mmAdd.defaultExpectation.paramPtrs == nil {
		mmAdd.defaultExpectation.paramPtrs = &IUserRepositoryMockAddParamPtrs{}
	}
	mmAdd.defaultExpectation.paramPtrs.user = &user
	mmAdd.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmAdd
}

// Inspect accepts an inspector function that has same arguments as the IUserRepository.Add
func (mmAdd *mIUserRepositoryMockAdd) Inspect(f func(ctx context.Context, user domain.User)) *mIUserRepositoryMockAdd {
	if mmAdd.mock.inspectFuncAdd != nil {
		mmAdd.mock.t.Fatalf("Inspect function is already set for IUserRepositoryMock.Add")
	}

	mmAdd.mock.inspectFuncAdd = f

	return mmAdd
}

// Return sets up results that will be returned by IUserRepository.Add
func (mmAdd *mIUserRepositoryMockAdd) Return(err error) *IUserRepositoryMock {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("IUserRepositoryMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &IUserRepositoryMockAddExpectation{mock: mmAdd.mock}
	}
	mmAdd.defaultExpectation.results = &IUserRepositoryMockAddResults{err}
	mmAdd.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAdd.mock
}

// Set uses given function f to mock the IUserRepository.Add method
func (mmAdd *mIUserRepositoryMockAdd) Set(f func(ctx context.Context, user domain.User) (err error)) *IUserRepositoryMock {
	if mmAdd.defaultExpectation != nil {
		mmAdd.mock.t.Fatalf("Default expectation is already set for the IUserRepository.Add method")
	}

	if len(mmAdd.expectations) > 0 {
		mmAdd.mock.t.Fatalf("Some expectations are already set for the IUserRepository.Add method")
	}

	mmAdd.mock.funcAdd = f
	mmAdd.mock.funcAddOrigin = minimock.CallerInfo(1)
	return mmAdd.mock
}

// When sets expectation for the IUserRepository.Add which will trigger the result defined by the following
// Then helper
func (mmAdd *mIUserRepositoryMockAdd) When(ctx context.Context, user domain.User) *IUserRepositoryMockAddExpectation {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("IUserRepositoryMock.Add mock is already set by Set")
	}

	expectation := &IUserRepositoryMockAddExpectation{
		mock:               mmAdd.mock,
		params:             &IUserRepositoryMockAddParams{ctx, user},
		expectationOrigins: IUserRepositoryMockAddExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAdd.expectations = append(mmAdd.expectations, expectation)
	return expectation
}

// Then sets up IUserRepository.Add return parameters for the expectation previously defined by the When method
func (e *IUserRepositoryMockAddExpectation) Then(err error) *IUserRepositoryMock {
	e.results = &IUserRepositoryMockAddResults{err}
	return e.mock
}

// Times sets number of times IUserRepository.Add should be invoked
func (mmAdd *mIUserRepositoryMockAdd) Times(n uint64) *mIUserRepositoryMockAdd {
	if n == 0 {
		mmAdd.mock.t.Fatalf("Times of IUserRepositoryMock.Add mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAdd.expectedInvocations, n)
	mmAdd.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAdd
}

func (mmAdd *mIUserRepositoryMockAdd) invocationsDone() bool {
	if len(mmAdd.expectations) == 0 && mmAdd.defaultExpectation == nil && mmAdd.mock.funcAdd == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAdd.mock.afterAddCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAdd.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Add implements mm_repository.IUserRepository
func (mmAdd *IUserRepositoryMock) Add(ctx context.Context, user domain.User) (err error) {
	mm_atomic.AddUint64(&mmAdd.beforeAddCounter, 1)
	defer mm_atomic.AddUint64(&mmAdd.afterAddCounter, 1)

	mmAdd.t.Helper()

	if mmAdd.inspectFuncAdd != nil {
		mmAdd.inspectFuncAdd(ctx, user)
	}

	mm_params := IUserRepositoryMockAddParams{ctx, user}

	// Record call args
	mmAdd.AddMock.mutex.Lock()
	mmAdd.AddMock.callArgs = append(mmAdd.AddMock.callArgs, &mm_params)
	mmAdd.AddMock.mutex.Unlock()

	for _, e := range mmAdd.AddMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAdd.AddMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAdd.AddMock.defaultExpectation.Counter, 1)
		mm_want := mmAdd.AddMock.defaultExpectation.params
		mm_want_ptrs := mmAdd.AddMock.defaultExpectation.paramPtrs

		mm_got := IUserRepositoryMockAddParams{ctx, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAdd.t.Errorf("IUserRepositoryMock.Add got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAdd.AddMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmAdd.t.Errorf("IUserRepositoryMock.Add got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAdd.AddMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAdd.t.Errorf("IUserRepositoryMock.Add got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAdd.AddMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAdd.AddMock.defaultExpectation.results
		if mm_results == nil {
			mmAdd.t.Fatal("No results are set for the IUserRepositoryMock.Add")
		}
		return (*mm_results).err
	}
	if mmAdd.funcAdd != nil {
		return mmAdd.funcAdd(ctx, user)
	}
	mmAdd.t.Fatalf("Unexpected call to IUserRepositoryMock.Add. %v %v", ctx, user)
	return
}

// AddAfterCounter returns a count of finished IUserRepositoryMock.Add invocations
func (mmAdd *IUserRepositoryMock) AddAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAdd.afterAddCounter)
}

// AddBeforeCounter returns a count of IUserRepositoryMock.Add invocations
func (mmAdd *IUserRepositoryMock) AddBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAdd.beforeAddCounter)
}

// Calls returns a list of arguments used in each call to IUserRepositoryMock.Add.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAdd *mIUserRepositoryMockAdd) Calls() []*IUserRepositoryMockAddParams {
	mmAdd.mutex.RLock()

	argCopy := make([]*IUserRepositoryMockAddParams, len(mmAdd.callArgs))
	copy(argCopy, mmAdd.callArgs)

	mmAdd.mutex.RUnlock()

	return argCopy
}

// MinimockAddDone returns true if the count of the Add invocations corresponds
// the number of defined expectations
func (m *IUserRepositoryMock) MinimockAddDone() bool {
	if m.AddMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddMock.invocationsDone()
}

// MinimockAddInspect logs each unmet expectation
func (m *IUserRepositoryMock) MinimockAddInspect() {
	for _, e := range m.AddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IUserRepositoryMock.Add at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddCounter := mm_atomic.LoadUint64(&m.afterAddCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddMock.defaultExpectation != nil && afterAddCounter < 1 {
		if m.AddMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IUserRepositoryMock.Add at\n%s", m.AddMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IUserRepositoryMock.Add at\n%s with params: %#v", m.AddMock.defaultExpectation.expectationOrigins.origin, *m.AddMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAdd != nil && afterAddCounter < 1 {
		m.t.Errorf("Expected call to IUserRepositoryMock.Add at\n%s", m.funcAddOrigin)
	}

	if !m.AddMock.invocationsDone() && afterAddCounter > 0 {
		m.t.Errorf("Expected %d calls to IUserRepositoryMock.Add at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddMock.expectedInvocations), m.AddMock.expectedInvocationsOrigin, afterAddCounter)
	}
}

type mIUserRepositoryMockAddLog struct {
	optional           bool
	mock               *IUserRepositoryMock
	defaultExpectation *IUserRepositoryMockAddLogExpectation
	expectations       []*IUserRepositoryMockAddLogExpectation

	callArgs []*IUserRepositoryMockAddLogParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IUserRepositoryMockAddLogExpectation specifies expectation struct of the IUserRepository.AddLog
type IUserRepositoryMockAddLogExpectation struct {
	mock               *IUserRepositoryMock
	params             *IUserRepositoryMockAddLogParams
	paramPtrs          *IUserRepositoryMockAddLogParamPtrs
	expectationOrigins IUserRepositoryMockAddLogExpectationOrigins
	results            *IUserRepositoryMockAddLogResults
	returnOrigin       string
	Counter            uint64
}

// IUserRepositoryMockAddLogParams contains parameters of the IUserRepository.AddLog
type IUserRepositoryMockAddLogParams struct {
	ctx context.Context
	log domain.UserLog
}

// IUserRepositoryMockAddLogParamPtrs contains pointers to parameters of the IUserRepository.AddLog
type IUserRepositoryMockAddLogParamPtrs struct {
	ctx *context.Context
	log *domain.UserLog
}

// IUserRepositoryMockAddLogResults contains results of the IUserRepository.AddLog
type IUserRepositoryMockAddLogResults struct {
	err error
}

// IUserRepositoryMockAddLogOrigins contains origins of expectations of the IUserRepository.AddLog
type IUserRepositoryMockAddLogExpectationOrigins struct {
	origin    string
	originCtx string
	originLog string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddLog *mIUserRepositoryMockAddLog) Optional() *mIUserRepositoryMockAddLog {
	mmAddLog.optional = true
	return mmAddLog
}

// Expect sets up expected params for IUserRepository.AddLog
func (mmAddLog *mIUserRepositoryMockAddLog) Expect(ctx context.Context, log domain.UserLog) *mIUserRepositoryMockAddLog {
	if mmAddLog.mock.funcAddLog != nil {
		mmAddLog.mock.t.Fatalf("IUserRepositoryMock.AddLog mock is already set by Set")
	}

	if mmAddLog.defaultExpectation == nil {
		mmAddLog.defaultExpectation = &IUserRepositoryMockAddLogExpectation{}
	}

	if mmAddLog.defaultExpectation.paramPtrs != nil {
		mmAddLog.mock.t.Fatalf("IUserRepositoryMock.AddLog mock is already set by ExpectParams functions")
	}

	mmAddLog.defaultExpectation.params = &IUserRepositoryMockAddLogParams{ctx, log}
	mmAddLog.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddLog.expectations {
		if minimock.Equal(e.params, mmAddLog.defaultExpectation.params) {
			mmAddLog.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddLog.defaultExpectation.params)
		}
	}

	return mmAddLog
}

// ExpectCtxParam1 sets up expected param ctx for IUserRepository.AddLog
func (mmAddLog *mIUserRepositoryMockAddLog) ExpectCtxParam1(ctx context.Context) *mIUserRepositoryMockAddLog {
	if mmAddLog.mock.funcAddLog != nil {
		mmAddLog.mock.t.Fatalf("IUserRepositoryMock.AddLog mock is already set by Set")
	}

	if mmAddLog.defaultExpectation == nil {
		mmAddLog.defaultExpectation = &IUserRepositoryMockAddLogExpectation{}
	}

	if mmAddLog.defaultExpectation.params != nil {
		mmAddLog.mock.t.Fatalf("IUserRepositoryMock.AddLog mock is already set by Expect")
	}

	if mmAddLog.defaultExpectation.paramPtrs == nil {
		mmAddLog.defaultExpectation.paramPtrs = &IUserRepositoryMockAddLogParamPtrs{}
	}
	mmAddLog.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddLog.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddLog
}

// ExpectLogParam2 sets up expected param log for IUserRepository.AddLog
func (mmAddLog *mIUserRepositoryMockAddLog) ExpectLogParam2(log domain.UserLog) *mIUserRepositoryMockAddLog {
	if mmAddLog.mock.funcAddLog != nil {
		mmAddLog.mock.t.Fatalf("IUserRepositoryMock.AddLog mock is already set by Set")
	}

	if mmAddLog.defaultExpectation == nil {
		mmAddLog.defaultExpectation = &IUserRepositoryMockAddLogExpectation{}
	}

	if mmAddLog.defaultExpectation.params != nil {
		mmAddLog.mock.t.Fatalf("IUserRepositoryMock.AddLog mock is already set by Expect")
	}

	if mmAddLog.defaultExpectation.paramPtrs == nil {
		mmAddLog.defaultExpectation.paramPtrs = &IUserRepositoryMockAddLogParamPtrs{}
	}
	mmAddLog.defaultExpectation.paramPtrs.log = &log
	mmAddLog.defaultExpectation.expectationOrigins.originLog = minimock.CallerInfo(1)

	return mmAddLog
}

// Inspect accepts an inspector function that has same arguments as the IUserRepository.AddLog
func (mmAddLog *mIUserRepositoryMockAddLog) Inspect(f func(ctx context.Context, log domain.UserLog)) *mIUserRepositoryMockAddLog {
	if mmAddLog.mock.inspectFuncAddLog != nil {
		mmAddLog.mock.t.Fatalf("Inspect function is already set for IUserRepositoryMock.AddLog")
	}

	mmAddLog.mock.inspectFuncAddLog = f

	return mmAddLog
}

// Return sets up results that will be returned by IUserRepository.AddLog
func (mmAddLog *mIUserRepositoryMockAddLog) Return(err error) *IUserRepositoryMock {
	if mmAddLog.mock.funcAddLog != nil {
		mmAddLog.mock.t.Fatalf("IUserRepositoryMock.AddLog mock is already set by Set")
	}

	if mmAddLog.defaultExpectation == nil {
		mmAddLog.defaultExpectation = &IUserRepositoryMockAddLogExpectation{mock: mmAddLog.mock}
	}
	mmAddLog.defaultExpectation.results = &IUserRepositoryMockAddLogResults{err}
	mmAddLog.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddLog.mock
}

// Set uses given function f to mock the IUserRepository.AddLog method
func (mmAddLog *mIUserRepositoryMockAddLog) Set(f func(ctx context.Context, log domain.UserLog) (err error)) *IUserRepositoryMock {
	if mmAddLog.defaultExpectation != nil {
		mmAddLog.mock.t.Fatalf("Default expectation is already set for the IUserRepository.AddLog method")
	}

	if len(mmAddLog.expectations) > 0 {
		mmAddLog.mock.t.Fatalf("Some expectations are already set for the IUserRepository.AddLog method")
	}

	mmAddLog.mock.funcAddLog = f
	mmAddLog.mock.funcAddLogOrigin = minimock.CallerInfo(1)
	return mmAddLog.mock
}

// When sets expectation for the IUserRepository.AddLog which will trigger the result defined by the following
// Then helper
func (mmAddLog *mIUserRepositoryMockAddLog) When(ctx context.Context, log domain.UserLog) *IUserRepositoryMockAddLogExpectation {
	if mmAddLog.mock.funcAddLog != nil {
		mmAddLog.mock.t.Fatalf("IUserRepositoryMock.AddLog mock is already set by Set")
	}

	expectation := &IUserRepositoryMockAddLogExpectation{
		mock:               mmAddLog.mock,
		params:             &IUserRepositoryMockAddLogParams{ctx, log},
		expectationOrigins: IUserRepositoryMockAddLogExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddLog.expectations = append(mmAddLog.expectations, expectation)
	return expectation
}

// Then sets up IUserRepository.AddLog return parameters for the expectation previously defined by the When method
func (e *IUserRepositoryMockAddLogExpectation) Then(err error) *IUserRepositoryMock {
	e.results = &IUserRepositoryMockAddLogResults{err}
	return e.mock
}

// Times sets number of times IUserRepository.AddLog should be invoked
func (mmAddLog *mIUserRepositoryMockAddLog) Times(n uint64) *mIUserRepositoryMockAddLog {
	if n == 0 {
		mmAddLog.mock.t.Fatalf("Times of IUserRepositoryMock.AddLog mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddLog.expectedInvocations, n)
	mmAddLog.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddLog
}

func (mmAddLog *mIUserRepositoryMockAddLog) invocationsDone() bool {
	if len(mmAddLog.expectations) == 0 && mmAddLog.defaultExpectation == nil && mmAddLog.mock.funcAddLog == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddLog.mock.afterAddLogCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddLog.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddLog implements mm_repository.IUserRepository
func (mmAddLog *IUserRepositoryMock) AddLog(ctx context.Context, log domain.UserLog) (err error) {
	mm_atomic.AddUint64(&mmAddLog.beforeAddLogCounter, 1)
	defer mm_atomic.AddUint64(&mmAddLog.afterAddLogCounter, 1)

	mmAddLog.t.Helper()

	if mmAddLog.inspectFuncAddLog != nil {
		mmAddLog.inspectFuncAddLog(ctx, log)
	}

	mm_params := IUserRepositoryMockAddLogParams{ctx, log}

	// Record call args
	mmAddLog.AddLogMock.mutex.Lock()
	mmAddLog.AddLogMock.callArgs = append(mmAddLog.AddLogMock.callArgs, &mm_params)
	mmAddLog.AddLogMock.mutex.Unlock()

	for _, e := range mmAddLog.AddLogMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddLog.AddLogMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddLog.AddLogMock.defaultExpectation.Counter, 1)
		mm_want := mmAddLog.AddLogMock.defaultExpectation.params
		mm_want_ptrs := mmAddLog.AddLogMock.defaultExpectation.paramPtrs

		mm_got := IUserRepositoryMockAddLogParams{ctx, log}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddLog.t.Errorf("IUserRepositoryMock.AddLog got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddLog.AddLogMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.log != nil && !minimock.Equal(*mm_want_ptrs.log, mm_got.log) {
				mmAddLog.t.Errorf("IUserRepositoryMock.AddLog got unexpected parameter log, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddLog.AddLogMock.defaultExpectation.expectationOrigins.originLog, *mm_want_ptrs.log, mm_got.log, minimock.Diff(*mm_want_ptrs.log, mm_got.log))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddLog.t.Errorf("IUserRepositoryMock.AddLog got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddLog.AddLogMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddLog.AddLogMock.defaultExpectation.results
		if mm_results == nil {
			mmAddLog.t.Fatal("No results are set for the IUserRepositoryMock.AddLog")
		}
		return (*mm_results).err
	}
	if mmAddLog.funcAddLog != nil {
		return mmAddLog.funcAddLog(ctx, log)
	}
	mmAddLog.t.Fatalf("Unexpected call to IUserRepositoryMock.AddLog. %v %v", ctx, log)
	return
}

// AddLogAfterCounter returns a count of finished IUserRepositoryMock.AddLog invocations
func (mmAddLog *IUserRepositoryMock) AddLogAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddLog.afterAddLogCounter)
}

// AddLogBeforeCounter returns a count of IUserRepositoryMock.AddLog invocations
func (mmAddLog *IUserRepositoryMock) AddLogBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddLog.beforeAddLogCounter)
}

// Calls returns a list of arguments used in each call to IUserRepositoryMock.AddLog.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddLog *mIUserRepositoryMockAddLog) Calls() []*IUserRepositoryMockAddLogParams {
	mmAddLog.mutex.RLock()

	argCopy := make([]*IUserRepositoryMockAddLogParams, len(mmAddLog.callArgs))
	copy(argCopy, mmAddLog.callArgs)

	mmAddLog.mutex.RUnlock()

	return argCopy
}

// MinimockAddLogDone returns true if the count of the AddLog invocations corresponds
// the number of defined expectations
func (m *IUserRepositoryMock) MinimockAddLogDone() bool {
	if m.AddLogMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddLogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddLogMock.invocationsDone()
}

// MinimockAddLogInspect logs each unmet expectation
func (m *IUserRepositoryMock) MinimockAddLogInspect() {
	for _, e := range m.AddLogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IUserRepositoryMock.AddLog at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddLogCounter := mm_atomic.LoadUint64(&m.afterAddLogCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddLogMock.defaultExpectation != nil && afterAddLogCounter < 1 {
		if m.AddLogMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IUserRepositoryMock.AddLog at\n%s", m.AddLogMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IUserRepositoryMock.AddLog at\n%s with params: %#v", m.AddLogMock.defaultExpectation.expectationOrigins.origin, *m.AddLogMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddLog != nil && afterAddLogCounter < 1 {
		m.t.Errorf("Expected call to IUserRepositoryMock.AddLog at\n%s", m.funcAddLogOrigin)
	}

	if !m.AddLogMock.invocationsDone() && afterAddLogCounter > 0 {
		m.t.Errorf("Expected %d calls to IUserRepositoryMock.AddLog at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddLogMock.expectedInvocations), m.AddLogMock.expectedInvocationsOrigin, afterAddLogCounter)
	}
}

type mIUserRepositoryMockGetByEmail struct {
	optional           bool
	mock               *IUserRepositoryMock
	defaultExpectation *IUserRepositoryMockGetByEmailExpectation
	expectations       []*IUserRepositoryMockGetByEmailExpectation

	callArgs []*IUserRepositoryMockGetByEmailParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IUserRepositoryMockGetByEmailExpectation specifies expectation struct of the IUserRepository.GetByEmail
type IUserRepositoryMockGetByEmailExpectation struct {
	mock               *IUserRepositoryMock
	params             *IUserRepositoryMockGetByEmailParams
	paramPtrs          *IUserRepositoryMockGetByEmailParamPtrs
	expectationOrigins IUserRepositoryMockGetByEmailExpectationOrigins
	results            *IUserRepositoryMockGetByEmailResults
	returnOrigin       string
	Counter            uint64
}

// IUserRepositoryMockGetByEmailParams contains parameters of the IUserRepository.GetByEmail
type IUserRepositoryMockGetByEmailParams struct {
	ctx   context.Context
	email string
}

// IUserRepositoryMockGetByEmailParamPtrs contains pointers to parameters of the IUserRepository.GetByEmail
type IUserRepositoryMockGetByEmailParamPtrs struct {
	ctx   *context.Context
	email *string
}

// IUserRepositoryMockGetByEmailResults contains results of the IUserRepository.GetByEmail
type IUserRepositoryMockGetByEmailResults struct {
	u1  domain.User
	err error
}

// IUserRepositoryMockGetByEmailOrigins contains origins of expectations of the IUserRepository.GetByEmail
type IUserRepositoryMockGetByEmailExpectationOrigins struct {
	origin      string
	originCtx   string
	originEmail string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetByEmail *mIUserRepositoryMockGetByEmail) Optional() *mIUserRepositoryMockGetByEmail {
	mmGetByEmail.optional = true
	return mmGetByEmail
}

// Expect sets up expected params for IUserRepository.GetByEmail
func (mmGetByEmail *mIUserRepositoryMockGetByEmail) Expect(ctx context.Context, email string) *mIUserRepositoryMockGetByEmail {
	if mmGetByEmail.mock.funcGetByEmail != nil {
		mmGetByEmail.mock.t.Fatalf("IUserRepositoryMock.GetByEmail mock is already set by Set")
	}

	if mmGetByEmail.defaultExpectation == nil {
		mmGetByEmail.defaultExpectation = &IUserRepositoryMockGetByEmailExpectation{}
	}

	if mmGetByEmail.defaultExpectation.paramPtrs != nil {
		mmGetByEmail.mock.t.Fatalf("IUserRepositoryMock.GetByEmail mock is already set by ExpectParams functions")
	}

	mmGetByEmail.defaultExpectation.params = &IUserRepositoryMockGetByEmailParams{ctx, email}
	mmGetByEmail.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetByEmail.expectations {
		if minimock.Equal(e.params, mmGetByEmail.defaultExpectation.params) {
			mmGetByEmail.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByEmail.defaultExpectation.params)
		}
	}

	return mmGetByEmail
}

// ExpectCtxParam1 sets up expected param ctx for IUserRepository.GetByEmail
func (mmGetByEmail *mIUserRepositoryMockGetByEmail) ExpectCtxParam1(ctx context.Context) *mIUserRepositoryMockGetByEmail {
	if mmGetByEmail.mock.funcGetByEmail != nil {
		mmGetByEmail.mock.t.Fatalf("IUserRepositoryMock.GetByEmail mock is already set by Set")
	}

	if mmGetByEmail.defaultExpectation == nil {
		mmGetByEmail.defaultExpectation = &IUserRepositoryMockGetByEmailExpectation{}
	}

	if mmGetByEmail.defaultExpectation.params != nil {
		mmGetByEmail.mock.t.Fatalf("IUserRepositoryMock.GetByEmail mock is already set by Expect")
	}

	if mmGetByEmail.defaultExpectation.paramPtrs == nil {
		mmGetByEmail.defaultExpectation.paramPtrs = &IUserRepositoryMockGetByEmailParamPtrs{}
	}
	mmGetByEmail.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetByEmail.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetByEmail
}

// ExpectEmailParam2 sets up expected param email for IUserRepository.GetByEmail
func (mmGetByEmail *mIUserRepositoryMockGetByEmail) ExpectEmailParam2(email string) *mIUserRepositoryMockGetByEmail {
	if mmGetByEmail.mock.funcGetByEmail != nil {
		mmGetByEmail.mock.t.Fatalf("IUserRepositoryMock.GetByEmail mock is already set by Set")
	}

	if mmGetByEmail.defaultExpectation == nil {
		mmGetByEmail.defaultExpectation = &IUserRepositoryMockGetByEmailExpectation{}
	}

	if mmGetByEmail.defaultExpectation.params != nil {
		mmGetByEmail.mock.t.Fatalf("IUserRepositoryMock.GetByEmail mock is already set by Expect")
	}

	if mmGetByEmail.defaultExpectation.paramPtrs == nil {
		mmGetByEmail.defaultExpectation.paramPtrs = &IUserRepositoryMockGetByEmailParamPtrs{}
	}
	mmGetByEmail.defaultExpectation.paramPtrs.email = &email
	mmGetByEmail.defaultExpectation.expectationOrigins.originEmail = minimock.CallerInfo(1)

	return mmGetByEmail
}

// Inspect accepts an inspector function that has same arguments as the IUserRepository.GetByEmail
func (mmGetByEmail *mIUserRepositoryMockGetByEmail) Inspect(f func(ctx context.Context, email string)) *mIUserRepositoryMockGetByEmail {
	if mmGetByEmail.mock.inspectFuncGetByEmail != nil {
		mmGetByEmail.mock.t.Fatalf("Inspect function is already set for IUserRepositoryMock.GetByEmail")
	}

	mmGetByEmail.mock.inspectFuncGetByEmail = f

	return mmGetByEmail
}

// Return sets up results that will be returned by IUserRepository.GetByEmail
func (mmGetByEmail *mIUserRepositoryMockGetByEmail) Return(u1 domain.User, err error) *IUserRepositoryMock {
	if mmGetByEmail.mock.funcGetByEmail != nil {
		mmGetByEmail.mock.t.Fatalf("IUserRepositoryMock.GetByEmail mock is already set by Set")
	}

	if mmGetByEmail.defaultExpectation == nil {
		mmGetByEmail.defaultExpectation = &IUserRepositoryMockGetByEmailExpectation{mock: mmGetByEmail.mock}
	}
	mmGetByEmail.defaultExpectation.results = &IUserRepositoryMockGetByEmailResults{u1, err}
	mmGetByEmail.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetByEmail.mock
}

// Set uses given function f to mock the IUserRepository.GetByEmail method
func (mmGetByEmail *mIUserRepositoryMockGetByEmail) Set(f func(ctx context.Context, email string) (u1 domain.User, err error)) *IUserRepositoryMock {
	if mmGetByEmail.defaultExpectation != nil {
		mmGetByEmail.mock.t.Fatalf("Default expectation is already set for the IUserRepository.GetByEmail method")
	}

	if len(mmGetByEmail.expectations) > 0 {
		mmGetByEmail.mock.t.Fatalf("Some expectations are already set for the IUserRepository.GetByEmail method")
	}

	mmGetByEmail.mock.funcGetByEmail = f
	mmGetByEmail.mock.funcGetByEmailOrigin = minimock.CallerInfo(1)
	return mmGetByEmail.mock
}

// When sets expectation for the IUserRepository.GetByEmail which will trigger the result defined by the following
// Then helper
func (mmGetByEmail *mIUserRepositoryMockGetByEmail) When(ctx context.Context, email string) *IUserRepositoryMockGetByEmailExpectation {
	if mmGetByEmail.mock.funcGetByEmail != nil {
		mmGetByEmail.mock.t.Fatalf("IUserRepositoryMock.GetByEmail mock is already set by Set")
	}

	expectation := &IUserRepositoryMockGetByEmailExpectation{
		mock:               mmGetByEmail.mock,
		params:             &IUserRepositoryMockGetByEmailParams{ctx, email},
		expectationOrigins: IUserRepositoryMockGetByEmailExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetByEmail.expectations = append(mmGetByEmail.expectations, expectation)
	return expectation
}

// Then sets up IUserRepository.GetByEmail return parameters for the expectation previously defined by the When method
func (e *IUserRepositoryMockGetByEmailExpectation) Then(u1 domain.User, err error) *IUserRepositoryMock {
	e.results = &IUserRepositoryMockGetByEmailResults{u1, err}
	return e.mock
}

// Times sets number of times IUserRepository.GetByEmail should be invoked
func (mmGetByEmail *mIUserRepositoryMockGetByEmail) Times(n uint64) *mIUserRepositoryMockGetByEmail {
	if n == 0 {
		mmGetByEmail.mock.t.Fatalf("Times of IUserRepositoryMock.GetByEmail mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetByEmail.expectedInvocations, n)
	mmGetByEmail.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetByEmail
}

func (mmGetByEmail *mIUserRepositoryMockGetByEmail) invocationsDone() bool {
	if len(mmGetByEmail.expectations) == 0 && mmGetByEmail.defaultExpectation == nil && mmGetByEmail.mock.funcGetByEmail == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetByEmail.mock.afterGetByEmailCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetByEmail.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetByEmail implements mm_repository.IUserRepository
func (mmGetByEmail *IUserRepositoryMock) GetByEmail(ctx context.Context, email string) (u1 domain.User, err error) {
	mm_atomic.AddUint64(&mmGetByEmail.beforeGetByEmailCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByEmail.afterGetByEmailCounter, 1)

	mmGetByEmail.t.Helper()

	if mmGetByEmail.inspectFuncGetByEmail != nil {
		mmGetByEmail.inspectFuncGetByEmail(ctx, email)
	}

	mm_params := IUserRepositoryMockGetByEmailParams{ctx, email}

	// Record call args
	mmGetByEmail.GetByEmailMock.mutex.Lock()
	mmGetByEmail.GetByEmailMock.callArgs = append(mmGetByEmail.GetByEmailMock.callArgs, &mm_params)
	mmGetByEmail.GetByEmailMock.mutex.Unlock()

	for _, e := range mmGetByEmail.GetByEmailMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmGetByEmail.GetByEmailMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByEmail.GetByEmailMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByEmail.GetByEmailMock.defaultExpectation.params
		mm_want_ptrs := mmGetByEmail.GetByEmailMock.defaultExpectation.paramPtrs

		mm_got := IUserRepositoryMockGetByEmailParams{ctx, email}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetByEmail.t.Errorf("IUserRepositoryMock.GetByEmail got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByEmail.GetByEmailMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.email != nil && !minimock.Equal(*mm_want_ptrs.email, mm_got.email) {
				mmGetByEmail.t.Errorf("IUserRepositoryMock.GetByEmail got unexpected parameter email, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByEmail.GetByEmailMock.defaultExpectation.expectationOrigins.originEmail, *mm_want_ptrs.email, mm_got.email, minimock.Diff(*mm_want_ptrs.email, mm_got.email))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByEmail.t.Errorf("IUserRepositoryMock.GetByEmail got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetByEmail.GetByEmailMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByEmail.GetByEmailMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByEmail.t.Fatal("No results are set for the IUserRepositoryMock.GetByEmail")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmGetByEmail.funcGetByEmail != nil {
		return mmGetByEmail.funcGetByEmail(ctx, email)
	}
	mmGetByEmail.t.Fatalf("Unexpected call to IUserRepositoryMock.GetByEmail. %v %v", ctx, email)
	return
}

// GetByEmailAfterCounter returns a count of finished IUserRepositoryMock.GetByEmail invocations
func (mmGetByEmail *IUserRepositoryMock) GetByEmailAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByEmail.afterGetByEmailCounter)
}

// GetByEmailBeforeCounter returns a count of IUserRepositoryMock.GetByEmail invocations
func (mmGetByEmail *IUserRepositoryMock) GetByEmailBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByEmail.beforeGetByEmailCounter)
}

// Calls returns a list of arguments used in each call to IUserRepositoryMock.GetByEmail.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByEmail *mIUserRepositoryMockGetByEmail) Calls() []*IUserRepositoryMockGetByEmailParams {
	mmGetByEmail.mutex.RLock()

	argCopy := make([]*IUserRepositoryMockGetByEmailParams, len(mmGetByEmail.callArgs))
	copy(argCopy, mmGetByEmail.callArgs)

	mmGetByEmail.mutex.RUnlock()

	return argCopy
}

// MinimockGetByEmailDone returns true if the count of the GetByEmail invocations corresponds
// the number of defined expectations
func (m *IUserRepositoryMock) MinimockGetByEmailDone() bool {
	if m.GetByEmailMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetByEmailMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetByEmailMock.invocationsDone()
}

// MinimockGetByEmailInspect logs each unmet expectation
func (m *IUserRepositoryMock) MinimockGetByEmailInspect() {
	for _, e := range m.GetByEmailMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IUserRepositoryMock.GetByEmail at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetByEmailCounter := mm_atomic.LoadUint64(&m.afterGetByEmailCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetByEmailMock.defaultExpectation != nil && afterGetByEmailCounter < 1 {
		if m.GetByEmailMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IUserRepositoryMock.GetByEmail at\n%s", m.GetByEmailMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IUserRepositoryMock.GetByEmail at\n%s with params: %#v", m.GetByEmailMock.defaultExpectation.expectationOrigins.origin, *m.GetByEmailMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByEmail != nil && afterGetByEmailCounter < 1 {
		m.t.Errorf("Expected call to IUserRepositoryMock.GetByEmail at\n%s", m.funcGetByEmailOrigin)
	}

	if !m.GetByEmailMock.invocationsDone() && afterGetByEmailCounter > 0 {
		m.t.Errorf("Expected %d calls to IUserRepositoryMock.GetByEmail at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetByEmailMock.expectedInvocations), m.GetByEmailMock.expectedInvocationsOrigin, afterGetByEmailCounter)
	}
}

type mIUserRepositoryMockLogs struct {
	optional           bool
	mock               *IUserRepositoryMock
	defaultExpectation *IUserRepositoryMockLogsExpectation
	expectations       []*IUserRepositoryMockLogsExpectation

	callArgs []*IUserRepositoryMockLogsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IUserRepositoryMockLogsExpectation specifies expectation struct of the IUserRepository.Logs
type IUserRepositoryMockLogsExpectation struct {
	mock               *IUserRepositoryMock
	params             *IUserRepositoryMockLogsParams
	paramPtrs          *IUserRepositoryMockLogsParamPtrs
	expectationOrigins IUserRepositoryMockLogsExpectationOrigins
	results            *IUserRepositoryMockLogsResults
	returnOrigin       string
	Counter            uint64
}

// IUserRepositoryMockLogsParams contains parameters of the IUserRepository.Logs
type IUserRepositoryMockLogsParams struct {
	ctx   context.Context
	email string
}

// IUserRepositoryMockLogsParamPtrs contains pointers to parameters of the IUserRepository.Logs
type IUserRepositoryMockLogsParamPtrs struct {
	ctx   *context.Context
	email *string
}

// IUserRepositoryMockLogsResults contains results of the IUserRepository.Logs
type IUserRepositoryMockLogsResults struct {
	ua1 []domain.UserLog
	err error
}

// IUserRepositoryMockLogsOrigins contains origins of expectations of the IUserRepository.Logs
type IUserRepositoryMockLogsExpectationOrigins struct {
	origin      string
	originCtx   string
	originEmail string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLogs *mIUserRepositoryMockLogs) Optional() *mIUserRepositoryMockLogs {
	mmLogs.optional = true
	return mmLogs
}

// Expect sets up expected params for IUserRepository.Logs
func (mmLogs *mIUserRepositoryMockLogs) Expect(ctx context.Context, email string) *mIUserRepositoryMockLogs {
	if mmLogs.mock.funcLogs != nil {
		mmLogs.mock.t.Fatalf("IUserRepositoryMock.Logs mock is already set by Set")
	}

	if mmLogs.defaultExpectation == nil {
		mmLogs.defaultExpectation = &IUserRepositoryMockLogsExpectation{}
	}

	if mmLogs.defaultExpectation.paramPtrs != nil {
		mmLogs.mock.t.Fatalf("IUserRepositoryMock.Logs mock is already set by ExpectParams functions")
	}

	mmLogs.defaultExpectation.params = &IUserRepositoryMockLogsParams{ctx, email}
	mmLogs.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmLogs.expectations {
		if minimock.Equal(e.params, mmLogs.defaultExpectation.params) {
			mmLogs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLogs.defaultExpectation.params)
		}
	}

	return mmLogs
}

// ExpectCtxParam1 sets up expected param ctx for IUserRepository.Logs
func (mmLogs *mIUserRepositoryMockLogs) ExpectCtxParam1(ctx context.Context) *mIUserRepositoryMockLogs {
	if mmLogs.mock.funcLogs != nil {
		mmLogs.mock.t.Fatalf("IUserRepositoryMock.Logs mock is already set by Set")
	}

	if mmLogs.defaultExpectation == nil {
		mmLogs.defaultExpectation = &IUserRepositoryMockLogsExpectation{}
	}

	if mmLogs.defaultExpectation.params != nil {
		mmLogs.mock.t.Fatalf("IUserRepositoryMock.Logs mock is already set by Expect")
	}

	if mmLogs.defaultExpectation.paramPtrs == nil {
		mmLogs.defaultExpectation.paramPtrs = &IUserRepositoryMockLogsParamPtrs{}
	}
	mmLogs.defaultExpectation.paramPtrs.ctx = &ctx
	mmLogs.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmLogs
}

// ExpectEmailParam2 sets up expected param email for IUserRepository.Logs
func (mmLogs *mIUserRepositoryMockLogs) ExpectEmailParam2(email string) *mIUserRepositoryMockLogs {
	if mmLogs.mock.funcLogs != nil {
		mmLogs.mock.t.Fatalf("IUserRepositoryMock.Logs mock is already set by Set")
	}

	if mmLogs.defaultExpectation == nil {
		mmLogs.defaultExpectation = &IUserRepositoryMockLogsExpectation{}
	}

	if mmLogs.defaultExpectation.params != nil {
		mmLogs.mock.t.Fatalf("IUserRepositoryMock.Logs mock is already set by Expect")
	}

	if mmLogs.defaultExpectation.paramPtrs == nil {
		mmLogs.defaultExpectation.paramPtrs = &IUserRepositoryMockLogsParamPtrs{}
	}
	mmLogs.defaultExpectation.paramPtrs.email = &email
	mmLogs.defaultExpectation.expectationOrigins.originEmail = minimock.CallerInfo(1)

	return mmLogs
}

// Inspect accepts an inspector function that has same arguments as the IUserRepository.Logs
func (mmLogs *mIUserRepositoryMockLogs) Inspect(f func(ctx context.Context, email string)) *mIUserRepositoryMockLogs {
	if mmLogs.mock.inspectFuncLogs != nil {
		mmLogs.mock.t.Fatalf("Inspect function is already set for IUserRepositoryMock.Logs")
	}

	mmLogs.mock.inspectFuncLogs = f

	return mmLogs
}

// Return sets up results that will be returned by IUserRepository.Logs
func (mmLogs *mIUserRepositoryMockLogs) Return(ua1 []domain.UserLog, err error) *IUserRepositoryMock {
	if mmLogs.mock.funcLogs != nil {
		mmLogs.mock.t.Fatalf("IUserRepositoryMock.Logs mock is already set by Set")
	}

	if mmLogs.defaultExpectation == nil {
		mmLogs.defaultExpectation = &IUserRepositoryMockLogsExpectation{mock: mmLogs.mock}
	}
	mmLogs.defaultExpectation.results = &IUserRepositoryMockLogsResults{ua1, err}
	mmLogs.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLogs.mock
}

// Set uses given function f to mock the IUserRepository.Logs method
func (mmLogs *mIUserRepositoryMockLogs) Set(f func(ctx context.Context, email string) (ua1 []domain.UserLog, err error)) *IUserRepositoryMock {
	if mmLogs.defaultExpectation != nil {
		mmLogs.mock.t.Fatalf("Default expectation is already set for the IUserRepository.Logs method")
	}

	if len(mmLogs.expectations) > 0 {
		mmLogs.mock.t.Fatalf("Some expectations are already set for the IUserRepository.Logs method")
	}

	mmLogs.mock.funcLogs = f
	mmLogs.mock.funcLogsOrigin = minimock.CallerInfo(1)
	return mmLogs.mock
}

// When sets expectation for the IUserRepository.Logs which will trigger the result defined by the following
// Then helper
func (mmLogs *mIUserRepositoryMockLogs) When(ctx context.Context, email string) *IUserRepositoryMockLogsExpectation {
	if mmLogs.mock.funcLogs != nil {
		mmLogs.mock.t.Fatalf("IUserRepositoryMock.Logs mock is already set by Set")
	}

	expectation := &IUserRepositoryMockLogsExpectation{
		mock:               mmLogs.mock,
		params:             &IUserRepositoryMockLogsParams{ctx, email},
		expectationOrigins: IUserRepositoryMockLogsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmLogs.expectations = append(mmLogs.expectations, expectation)
	return expectation
}

// Then sets up IUserRepository.Logs return parameters for the expectation previously defined by the When method
func (e *IUserRepositoryMockLogsExpectation) Then(ua1 []domain.UserLog, err error) *IUserRepositoryMock {
	e.results = &IUserRepositoryMockLogsResults{ua1, err}
	return e.mock
}

// Times sets number of times IUserRepository.Logs should be invoked
func (mmLogs *mIUserRepositoryMockLogs) Times(n uint64) *mIUserRepositoryMockLogs {
	if n == 0 {
		mmLogs.mock.t.Fatalf("Times of IUserRepositoryMock.Logs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLogs.expectedInvocations, n)
	mmLogs.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLogs
}

func (mmLogs *mIUserRepositoryMockLogs) invocationsDone() bool {
	if len(mmLogs.expectations) == 0 && mmLogs.defaultExpectation == nil && mmLogs.mock.funcLogs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLogs.mock.afterLogsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLogs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Logs implements mm_repository.IUserRepository
func (mmLogs *IUserRepositoryMock) Logs(ctx context.Context, email string) (ua1 []domain.UserLog, err error) {
	mm_atomic.AddUint64(&mmLogs.beforeLogsCounter, 1)
	defer mm_atomic.AddUint64(&mmLogs.afterLogsCounter, 1)

	mmLogs.t.Helper()

	if mmLogs.inspectFuncLogs != nil {
		mmLogs.inspectFuncLogs(ctx, email)
	}

	mm_params := IUserRepositoryMockLogsParams{ctx, email}

	// Record call args
	mmLogs.LogsMock.mutex.Lock()
	mmLogs.LogsMock.callArgs = append(mmLogs.LogsMock.callArgs, &mm_params)
	mmLogs.LogsMock.mutex.Unlock()

	for _, e := range mmLogs.LogsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ua1, e.results.err
		}
	}

	if mmLogs.LogsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLogs.LogsMock.defaultExpectation.Counter, 1)
		mm_want := mmLogs.LogsMock.defaultExpectation.params
		mm_want_ptrs := mmLogs.LogsMock.defaultExpectation.paramPtrs

		mm_got := IUserRepositoryMockLogsParams{ctx, email}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLogs.t.Errorf("IUserRepositoryMock.Logs got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLogs.LogsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.email != nil && !minimock.Equal(*mm_want_ptrs.email, mm_got.email) {
				mmLogs.t.Errorf("IUserRepositoryMock.Logs got unexpected parameter email, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLogs.LogsMock.defaultExpectation.expectationOrigins.originEmail, *mm_want_ptrs.email, mm_got.email, minimock.Diff(*mm_want_ptrs.email, mm_got.email))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLogs.t.Errorf("IUserRepositoryMock.Logs got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmLogs.LogsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLogs.LogsMock.defaultExpectation.results
		if mm_results == nil {
			mmLogs.t.Fatal("No results are set for the IUserRepositoryMock.Logs")
		}
		return (*mm_results).ua1, (*mm_results).err
	}
	if mmLogs.funcLogs != nil {
		return mmLogs.funcLogs(ctx, email)
	}
	mmLogs.t.Fatalf("Unexpected call to IUserRepositoryMock.Logs. %v %v", ctx, email)
	return
}

// LogsAfterCounter returns a count of finished IUserRepositoryMock.Logs invocations
func (mmLogs *IUserRepositoryMock) LogsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogs.afterLogsCounter)
}

// LogsBeforeCounter returns a count of IUserRepositoryMock.Logs invocations
func (mmLogs *IUserRepositoryMock) LogsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogs.beforeLogsCounter)
}

// Calls returns a list of arguments used in each call to IUserRepositoryMock.Logs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLogs *mIUserRepositoryMockLogs) Calls() []*IUserRepositoryMockLogsParams {
	mmLogs.mutex.RLock()

	argCopy := make([]*IUserRepositoryMockLogsParams, len(mmLogs.callArgs))
	copy(argCopy, mmLogs.callArgs)

	mmLogs.mutex.RUnlock()

	return argCopy
}

// MinimockLogsDone returns true if the count of the Logs invocations corresponds
// the number of defined expectations
func (m *IUserRepositoryMock) MinimockLogsDone() bool {
	if m.LogsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LogsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LogsMock.invocationsDone()
}

// MinimockLogsInspect logs each unmet expectation
func (m *IUserRepositoryMock) MinimockLogsInspect() {
	for _, e := range m.LogsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IUserRepositoryMock.Logs at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterLogsCounter := mm_atomic.LoadUint64(&m.afterLogsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LogsMock.defaultExpectation != nil && afterLogsCounter < 1 {
		if m.LogsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IUserRepositoryMock.Logs at\n%s", m.LogsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IUserRepositoryMock.Logs at\n%s with params: %#v", m.LogsMock.defaultExpectation.expectationOrigins.origin, *m.LogsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLogs != nil && afterLogsCounter < 1 {
		m.t.Errorf("Expected call to IUserRepositoryMock.Logs at\n%s", m.funcLogsOrigin)
	}

	if !m.LogsMock.invocationsDone() && afterLogsCounter > 0 {
		m.t.Errorf("Expected %d calls to IUserRepositoryMock.Logs at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LogsMock.expectedInvocations), m.LogsMock.expectedInvocationsOrigin, afterLogsCounter)
	}
}

type mIUserRepositoryMockUpdate struct {
	optional           bool
	mock               *IUserRepositoryMock
	defaultExpectation *IUserRepositoryMockUpdateExpectation
	expectations       []*IUserRepositoryMockUpdateExpectation

	callArgs []*IUserRepositoryMockUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IUserRepositoryMockUpdateExpectation specifies expectation struct of the IUserRepository.Update
type IUserRepositoryMockUpdateExpectation struct {
	mock               *IUserRepositoryMock
	params             *IUserRepositoryMockUpdateParams
	paramPtrs          *IUserRepositoryMockUpdateParamPtrs
	expectationOrigins IUserRepositoryMockUpdateExpectationOrigins
	results            *IUserRepositoryMockUpdateResults
	returnOrigin       string
	Counter            uint64
}

// IUserRepositoryMockUpdateParams contains parameters of the IUserRepository.Update
type IUserRepositoryMockUpdateParams struct {
	ctx  context.Context
	user domain.User
}

// IUserRepositoryMockUpdateParamPtrs contains pointers to parameters of the IUserRepository.Update
type IUserRepositoryMockUpdateParamPtrs struct {
	ctx  *context.Context
	user *domain.User
}

// IUserRepositoryMockUpdateResults contains results of the IUserRepository.Update
type IUserRepositoryMockUpdateResults struct {
	err error
}

// IUserRepositoryMockUpdateOrigins contains origins of expectations of the IUserRepository.Update
type IUserRepositoryMockUpdateExpectationOrigins struct {
	origin     string
	originCtx  string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mIUserRepositoryMockUpdate) Optional() *mIUserRepositoryMockUpdate {
	mmUpdate.optional = true
	return mmUpdate
}

// Expect sets up expected params for IUserRepository.Update
func (mmUpdate *mIUserRepositoryMockUpdate) Expect(ctx context.Context, user domain.User) *mIUserRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("IUserRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &IUserRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.paramPtrs != nil {
		mmUpdate.mock.t.Fatalf("IUserRepositoryMock.Update mock is already set by ExpectParams functions")
	}

	mmUpdate.defaultExpectation.params = &IUserRepositoryMockUpdateParams{ctx, user}
	mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// ExpectCtxParam1 sets up expected param ctx for IUserRepository.Update
func (mmUpdate *mIUserRepositoryMockUpdate) ExpectCtxParam1(ctx context.Context) *mIUserRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("IUserRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &IUserRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("IUserRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &IUserRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectUserParam2 sets up expected param user for IUserRepository.Update
func (mmUpdate *mIUserRepositoryMockUpdate) ExpectUserParam2(user domain.User) *mIUserRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("IUserRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &IUserRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("IUserRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &IUserRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.user = &user
	mmUpdate.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the IUserRepository.Update
func (mmUpdate *mIUserRepositoryMockUpdate) Inspect(f func(ctx context.Context, user domain.User)) *mIUserRepositoryMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for IUserRepositoryMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by IUserRepository.Update
func (mmUpdate *mIUserRepositoryMockUpdate) Return(err error) *IUserRepositoryMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("IUserRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &IUserRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &IUserRepositoryMockUpdateResults{err}
	mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// Set uses given function f to mock the IUserRepository.Update method
func (mmUpdate *mIUserRepositoryMockUpdate) Set(f func(ctx context.Context, user domain.User) (err error)) *IUserRepositoryMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the IUserRepository.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the IUserRepository.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// When sets expectation for the IUserRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mIUserRepositoryMockUpdate) When(ctx context.Context, user domain.User) *IUserRepositoryMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("IUserRepositoryMock.Update mock is already set by Set")
	}

	expectation := &IUserRepositoryMockUpdateExpectation{
		mock:               mmUpdate.mock,
		params:             &IUserRepositoryMockUpdateParams{ctx, user},
		expectationOrigins: IUserRepositoryMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up IUserRepository.Update return parameters for the expectation previously defined by the When method
func (e *IUserRepositoryMockUpdateExpectation) Then(err error) *IUserRepositoryMock {
	e.results = &IUserRepositoryMockUpdateResults{err}
	return e.mock
}

// Times sets number of times IUserRepository.Update should be invoked
func (mmUpdate *mIUserRepositoryMockUpdate) Times(n uint64) *mIUserRepositoryMockUpdate {
	if n == 0 {
		mmUpdate.mock.t.Fatalf("Times of IUserRepositoryMock.Update mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdate.expectedInvocations, n)
	mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdate
}

func (mmUpdate *mIUserRepositoryMockUpdate) invocationsDone() bool {
	if len(mmUpdate.expectations) == 0 && mmUpdate.defaultExpectation == nil && mmUpdate.mock.funcUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdate.mock.afterUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Update implements mm_repository.IUserRepository
func (mmUpdate *IUserRepositoryMock) Update(ctx context.Context, user domain.User) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	mmUpdate.t.Helper()

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, user)
	}

	mm_params := IUserRepositoryMockUpdateParams{ctx, user}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

		mm_got := IUserRepositoryMockUpdateParams{ctx, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdate.t.Errorf("IUserRepositoryMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmUpdate.t.Errorf("IUserRepositoryMock.Update got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("IUserRepositoryMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the IUserRepositoryMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, user)
	}
	mmUpdate.t.Fatalf("Unexpected call to IUserRepositoryMock.Update. %v %v", ctx, user)
	return
}

// UpdateAfterCounter returns a count of finished IUserRepositoryMock.Update invocations
func (mmUpdate *IUserRepositoryMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of IUserRepositoryMock.Update invocations
func (mmUpdate *IUserRepositoryMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to IUserRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mIUserRepositoryMockUpdate) Calls() []*IUserRepositoryMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*IUserRepositoryMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *IUserRepositoryMock) MinimockUpdateDone() bool {
	if m.UpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMock.invocationsDone()
}

// MinimockUpdateInspect logs each unmet expectation
func (m *IUserRepositoryMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IUserRepositoryMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCounter := mm_atomic.LoadUint64(&m.afterUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && afterUpdateCounter < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IUserRepositoryMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IUserRepositoryMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && afterUpdateCounter < 1 {
		m.t.Errorf("Expected call to IUserRepositoryMock.Update at\n%s", m.funcUpdateOrigin)
	}

	if !m.UpdateMock.invocationsDone() && afterUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to IUserRepositoryMock.Update at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IUserRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddInspect()

			m.MinimockAddLogInspect()

			m.MinimockGetByEmailInspect()

			m.MinimockLogsInspect()

			m.MinimockUpdateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IUserRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IUserRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddDone() &&
		m.MinimockAddLogDone() &&
		m.MinimockGetByEmailDone() &&
		m.MinimockLogsDone() &&
		m.MinimockUpdateDone()
}
