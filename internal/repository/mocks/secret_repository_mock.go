// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/maisiq/go-auth-service/internal/repository.SecretRepository -o secret_repository_mock.go -n SecretRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// SecretRepositoryMock implements mm_repository.SecretRepository
type SecretRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetKID          func(ctx context.Context, keyName string) (s1 string, err error)
	funcGetKIDOrigin    string
	inspectFuncGetKID   func(ctx context.Context, keyName string)
	afterGetKIDCounter  uint64
	beforeGetKIDCounter uint64
	GetKIDMock          mSecretRepositoryMockGetKID

	funcGetPublicKeys          func(ctx context.Context, keyName string) (m1 map[string]string, err error)
	funcGetPublicKeysOrigin    string
	inspectFuncGetPublicKeys   func(ctx context.Context, keyName string)
	afterGetPublicKeysCounter  uint64
	beforeGetPublicKeysCounter uint64
	GetPublicKeysMock          mSecretRepositoryMockGetPublicKeys

	funcSignJWT          func(ctx context.Context, data string, keyName string) (s1 string, err error)
	funcSignJWTOrigin    string
	inspectFuncSignJWT   func(ctx context.Context, data string, keyName string)
	afterSignJWTCounter  uint64
	beforeSignJWTCounter uint64
	SignJWTMock          mSecretRepositoryMockSignJWT
}

// NewSecretRepositoryMock returns a mock for mm_repository.SecretRepository
func NewSecretRepositoryMock(t minimock.Tester) *SecretRepositoryMock {
	m := &SecretRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetKIDMock = mSecretRepositoryMockGetKID{mock: m}
	m.GetKIDMock.callArgs = []*SecretRepositoryMockGetKIDParams{}

	m.GetPublicKeysMock = mSecretRepositoryMockGetPublicKeys{mock: m}
	m.GetPublicKeysMock.callArgs = []*SecretRepositoryMockGetPublicKeysParams{}

	m.SignJWTMock = mSecretRepositoryMockSignJWT{mock: m}
	m.SignJWTMock.callArgs = []*SecretRepositoryMockSignJWTParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mSecretRepositoryMockGetKID struct {
	optional           bool
	mock               *SecretRepositoryMock
	defaultExpectation *SecretRepositoryMockGetKIDExpectation
	expectations       []*SecretRepositoryMockGetKIDExpectation

	callArgs []*SecretRepositoryMockGetKIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SecretRepositoryMockGetKIDExpectation specifies expectation struct of the SecretRepository.GetKID
type SecretRepositoryMockGetKIDExpectation struct {
	mock               *SecretRepositoryMock
	params             *SecretRepositoryMockGetKIDParams
	paramPtrs          *SecretRepositoryMockGetKIDParamPtrs
	expectationOrigins SecretRepositoryMockGetKIDExpectationOrigins
	results            *SecretRepositoryMockGetKIDResults
	returnOrigin       string
	Counter            uint64
}

// SecretRepositoryMockGetKIDParams contains parameters of the SecretRepository.GetKID
type SecretRepositoryMockGetKIDParams struct {
	ctx     context.Context
	keyName string
}

// SecretRepositoryMockGetKIDParamPtrs contains pointers to parameters of the SecretRepository.GetKID
type SecretRepositoryMockGetKIDParamPtrs struct {
	ctx     *context.Context
	keyName *string
}

// SecretRepositoryMockGetKIDResults contains results of the SecretRepository.GetKID
type SecretRepositoryMockGetKIDResults struct {
	s1  string
	err error
}

// SecretRepositoryMockGetKIDOrigins contains origins of expectations of the SecretRepository.GetKID
type SecretRepositoryMockGetKIDExpectationOrigins struct {
	origin        string
	originCtx     string
	originKeyName string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetKID *mSecretRepositoryMockGetKID) Optional() *mSecretRepositoryMockGetKID {
	mmGetKID.optional = true
	return mmGetKID
}

// Expect sets up expected params for SecretRepository.GetKID
func (mmGetKID *mSecretRepositoryMockGetKID) Expect(ctx context.Context, keyName string) *mSecretRepositoryMockGetKID {
	if mmGetKID.mock.funcGetKID != nil {
		mmGetKID.mock.t.Fatalf("SecretRepositoryMock.GetKID mock is already set by Set")
	}

	if mmGetKID.defaultExpectation == nil {
		mmGetKID.defaultExpectation = &SecretRepositoryMockGetKIDExpectation{}
	}

	if mmGetKID.defaultExpectation.paramPtrs != nil {
		mmGetKID.mock.t.Fatalf("SecretRepositoryMock.GetKID mock is already set by ExpectParams functions")
	}

	mmGetKID.defaultExpectation.params = &SecretRepositoryMockGetKIDParams{ctx, keyName}
	mmGetKID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetKID.expectations {
		if minimock.Equal(e.params, mmGetKID.defaultExpectation.params) {
			mmGetKID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetKID.defaultExpectation.params)
		}
	}

	return mmGetKID
}

// ExpectCtxParam1 sets up expected param ctx for SecretRepository.GetKID
func (mmGetKID *mSecretRepositoryMockGetKID) ExpectCtxParam1(ctx context.Context) *mSecretRepositoryMockGetKID {
	if mmGetKID.mock.funcGetKID != nil {
		mmGetKID.mock.t.Fatalf("SecretRepositoryMock.GetKID mock is already set by Set")
	}

	if mmGetKID.defaultExpectation == nil {
		mmGetKID.defaultExpectation = &SecretRepositoryMockGetKIDExpectation{}
	}

	if mmGetKID.defaultExpectation.params != nil {
		mmGetKID.mock.t.Fatalf("SecretRepositoryMock.GetKID mock is already set by Expect")
	}

	if mmGetKID.defaultExpectation.paramPtrs == nil {
		mmGetKID.defaultExpectation.paramPtrs = &SecretRepositoryMockGetKIDParamPtrs{}
	}
	mmGetKID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetKID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetKID
}

// ExpectKeyNameParam2 sets up expected param keyName for SecretRepository.GetKID
func (mmGetKID *mSecretRepositoryMockGetKID) ExpectKeyNameParam2(keyName string) *mSecretRepositoryMockGetKID {
	if mmGetKID.mock.funcGetKID != nil {
		mmGetKID.mock.t.Fatalf("SecretRepositoryMock.GetKID mock is already set by Set")
	}

	if mmGetKID.defaultExpectation == nil {
		mmGetKID.defaultExpectation = &SecretRepositoryMockGetKIDExpectation{}
	}

	if mmGetKID.defaultExpectation.params != nil {
		mmGetKID.mock.t.Fatalf("SecretRepositoryMock.GetKID mock is already set by Expect")
	}

	if mmGetKID.defaultExpectation.paramPtrs == nil {
		mmGetKID.defaultExpectation.paramPtrs = &SecretRepositoryMockGetKIDParamPtrs{}
	}
	mmGetKID.defaultExpectation.paramPtrs.keyName = &keyName
	mmGetKID.defaultExpectation.expectationOrigins.originKeyName = minimock.CallerInfo(1)

	return mmGetKID
}

// Inspect accepts an inspector function that has same arguments as the SecretRepository.GetKID
func (mmGetKID *mSecretRepositoryMockGetKID) Inspect(f func(ctx context.Context, keyName string)) *mSecretRepositoryMockGetKID {
	if mmGetKID.mock.inspectFuncGetKID != nil {
		mmGetKID.mock.t.Fatalf("Inspect function is already set for SecretRepositoryMock.GetKID")
	}

	mmGetKID.mock.inspectFuncGetKID = f

	return mmGetKID
}

// Return sets up results that will be returned by SecretRepository.GetKID
func (mmGetKID *mSecretRepositoryMockGetKID) Return(s1 string, err error) *SecretRepositoryMock {
	if mmGetKID.mock.funcGetKID != nil {
		mmGetKID.mock.t.Fatalf("SecretRepositoryMock.GetKID mock is already set by Set")
	}

	if mmGetKID.defaultExpectation == nil {
		mmGetKID.defaultExpectation = &SecretRepositoryMockGetKIDExpectation{mock: mmGetKID.mock}
	}
	mmGetKID.defaultExpectation.results = &SecretRepositoryMockGetKIDResults{s1, err}
	mmGetKID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetKID.mock
}

// Set uses given function f to mock the SecretRepository.GetKID method
func (mmGetKID *mSecretRepositoryMockGetKID) Set(f func(ctx context.Context, keyName string) (s1 string, err error)) *SecretRepositoryMock {
	if mmGetKID.defaultExpectation != nil {
		mmGetKID.mock.t.Fatalf("Default expectation is already set for the SecretRepository.GetKID method")
	}

	if len(mmGetKID.expectations) > 0 {
		mmGetKID.mock.t.Fatalf("Some expectations are already set for the SecretRepository.GetKID method")
	}

	mmGetKID.mock.funcGetKID = f
	mmGetKID.mock.funcGetKIDOrigin = minimock.CallerInfo(1)
	return mmGetKID.mock
}

// When sets expectation for the SecretRepository.GetKID which will trigger the result defined by the following
// Then helper
func (mmGetKID *mSecretRepositoryMockGetKID) When(ctx context.Context, keyName string) *SecretRepositoryMockGetKIDExpectation {
	if mmGetKID.mock.funcGetKID != nil {
		mmGetKID.mock.t.Fatalf("SecretRepositoryMock.GetKID mock is already set by Set")
	}

	expectation := &SecretRepositoryMockGetKIDExpectation{
		mock:               mmGetKID.mock,
		params:             &SecretRepositoryMockGetKIDParams{ctx, keyName},
		expectationOrigins: SecretRepositoryMockGetKIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetKID.expectations = append(mmGetKID.expectations, expectation)
	return expectation
}

// Then sets up SecretRepository.GetKID return parameters for the expectation previously defined by the When method
func (e *SecretRepositoryMockGetKIDExpectation) Then(s1 string, err error) *SecretRepositoryMock {
	e.results = &SecretRepositoryMockGetKIDResults{s1, err}
	return e.mock
}

// Times sets number of times SecretRepository.GetKID should be invoked
func (mmGetKID *mSecretRepositoryMockGetKID) Times(n uint64) *mSecretRepositoryMockGetKID {
	if n == 0 {
		mmGetKID.mock.t.Fatalf("Times of SecretRepositoryMock.GetKID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetKID.expectedInvocations, n)
	mmGetKID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetKID
}

func (mmGetKID *mSecretRepositoryMockGetKID) invocationsDone() bool {
	if len(mmGetKID.expectations) == 0 && mmGetKID.defaultExpectation == nil && mmGetKID.mock.funcGetKID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetKID.mock.afterGetKIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetKID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetKID implements mm_repository.SecretRepository
func (mmGetKID *SecretRepositoryMock) GetKID(ctx context.Context, keyName string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGetKID.beforeGetKIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetKID.afterGetKIDCounter, 1)

	mmGetKID.t.Helper()

	if mmGetKID.inspectFuncGetKID != nil {
		mmGetKID.inspectFuncGetKID(ctx, keyName)
	}

	mm_params := SecretRepositoryMockGetKIDParams{ctx, keyName}

	// Record call args
	mmGetKID.GetKIDMock.mutex.Lock()
	mmGetKID.GetKIDMock.callArgs = append(mmGetKID.GetKIDMock.callArgs, &mm_params)
	mmGetKID.GetKIDMock.mutex.Unlock()

	for _, e := range mmGetKID.GetKIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetKID.GetKIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetKID.GetKIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetKID.GetKIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetKID.GetKIDMock.defaultExpectation.paramPtrs

		mm_got := SecretRepositoryMockGetKIDParams{ctx, keyName}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetKID.t.Errorf("SecretRepositoryMock.GetKID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKID.GetKIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.keyName != nil && !minimock.Equal(*mm_want_ptrs.keyName, mm_got.keyName) {
				mmGetKID.t.Errorf("SecretRepositoryMock.GetKID got unexpected parameter keyName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetKID.GetKIDMock.defaultExpectation.expectationOrigins.originKeyName, *mm_want_ptrs.keyName, mm_got.keyName, minimock.Diff(*mm_want_ptrs.keyName, mm_got.keyName))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetKID.t.Errorf("SecretRepositoryMock.GetKID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetKID.GetKIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetKID.GetKIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetKID.t.Fatal("No results are set for the SecretRepositoryMock.GetKID")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetKID.funcGetKID != nil {
		return mmGetKID.funcGetKID(ctx, keyName)
	}
	mmGetKID.t.Fatalf("Unexpected call to SecretRepositoryMock.GetKID. %v %v", ctx, keyName)
	return
}

// GetKIDAfterCounter returns a count of finished SecretRepositoryMock.GetKID invocations
func (mmGetKID *SecretRepositoryMock) GetKIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKID.afterGetKIDCounter)
}

// GetKIDBeforeCounter returns a count of SecretRepositoryMock.GetKID invocations
func (mmGetKID *SecretRepositoryMock) GetKIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetKID.beforeGetKIDCounter)
}

// Calls returns a list of arguments used in each call to SecretRepositoryMock.GetKID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetKID *mSecretRepositoryMockGetKID) Calls() []*SecretRepositoryMockGetKIDParams {
	mmGetKID.mutex.RLock()

	argCopy := make([]*SecretRepositoryMockGetKIDParams, len(mmGetKID.callArgs))
	copy(argCopy, mmGetKID.callArgs)

	mmGetKID.mutex.RUnlock()

	return argCopy
}

// MinimockGetKIDDone returns true if the count of the GetKID invocations corresponds
// the number of defined expectations
func (m *SecretRepositoryMock) MinimockGetKIDDone() bool {
	if m.GetKIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetKIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetKIDMock.invocationsDone()
}

// MinimockGetKIDInspect logs each unmet expectation
func (m *SecretRepositoryMock) MinimockGetKIDInspect() {
	for _, e := range m.GetKIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SecretRepositoryMock.GetKID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetKIDCounter := mm_atomic.LoadUint64(&m.afterGetKIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetKIDMock.defaultExpectation != nil && afterGetKIDCounter < 1 {
		if m.GetKIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SecretRepositoryMock.GetKID at\n%s", m.GetKIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SecretRepositoryMock.GetKID at\n%s with params: %#v", m.GetKIDMock.defaultExpectation.expectationOrigins.origin, *m.GetKIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetKID != nil && afterGetKIDCounter < 1 {
		m.t.Errorf("Expected call to SecretRepositoryMock.GetKID at\n%s", m.funcGetKIDOrigin)
	}

	if !m.GetKIDMock.invocationsDone() && afterGetKIDCounter > 0 {
		m.t.Errorf("Expected %d calls to SecretRepositoryMock.GetKID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetKIDMock.expectedInvocations), m.GetKIDMock.expectedInvocationsOrigin, afterGetKIDCounter)
	}
}

type mSecretRepositoryMockGetPublicKeys struct {
	optional           bool
	mock               *SecretRepositoryMock
	defaultExpectation *SecretRepositoryMockGetPublicKeysExpectation
	expectations       []*SecretRepositoryMockGetPublicKeysExpectation

	callArgs []*SecretRepositoryMockGetPublicKeysParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SecretRepositoryMockGetPublicKeysExpectation specifies expectation struct of the SecretRepository.GetPublicKeys
type SecretRepositoryMockGetPublicKeysExpectation struct {
	mock               *SecretRepositoryMock
	params             *SecretRepositoryMockGetPublicKeysParams
	paramPtrs          *SecretRepositoryMockGetPublicKeysParamPtrs
	expectationOrigins SecretRepositoryMockGetPublicKeysExpectationOrigins
	results            *SecretRepositoryMockGetPublicKeysResults
	returnOrigin       string
	Counter            uint64
}

// SecretRepositoryMockGetPublicKeysParams contains parameters of the SecretRepository.GetPublicKeys
type SecretRepositoryMockGetPublicKeysParams struct {
	ctx     context.Context
	keyName string
}

// SecretRepositoryMockGetPublicKeysParamPtrs contains pointers to parameters of the SecretRepository.GetPublicKeys
type SecretRepositoryMockGetPublicKeysParamPtrs struct {
	ctx     *context.Context
	keyName *string
}

// SecretRepositoryMockGetPublicKeysResults contains results of the SecretRepository.GetPublicKeys
type SecretRepositoryMockGetPublicKeysResults struct {
	m1  map[string]string
	err error
}

// SecretRepositoryMockGetPublicKeysOrigins contains origins of expectations of the SecretRepository.GetPublicKeys
type SecretRepositoryMockGetPublicKeysExpectationOrigins struct {
	origin        string
	originCtx     string
	originKeyName string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPublicKeys *mSecretRepositoryMockGetPublicKeys) Optional() *mSecretRepositoryMockGetPublicKeys {
	mmGetPublicKeys.optional = true
	return mmGetPublicKeys
}

// Expect sets up expected params for SecretRepository.GetPublicKeys
func (mmGetPublicKeys *mSecretRepositoryMockGetPublicKeys) Expect(ctx context.Context, keyName string) *mSecretRepositoryMockGetPublicKeys {
	if mmGetPublicKeys.mock.funcGetPublicKeys != nil {
		mmGetPublicKeys.mock.t.Fatalf("SecretRepositoryMock.GetPublicKeys mock is already set by Set")
	}

	if mmGetPublicKeys.defaultExpectation == nil {
		mmGetPublicKeys.defaultExpectation = &SecretRepositoryMockGetPublicKeysExpectation{}
	}

	if mmGetPublicKeys.defaultExpectation.paramPtrs != nil {
		mmGetPublicKeys.mock.t.Fatalf("SecretRepositoryMock.GetPublicKeys mock is already set by ExpectParams functions")
	}

	mmGetPublicKeys.defaultExpectation.params = &SecretRepositoryMockGetPublicKeysParams{ctx, keyName}
	mmGetPublicKeys.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPublicKeys.expectations {
		if minimock.Equal(e.params, mmGetPublicKeys.defaultExpectation.params) {
			mmGetPublicKeys.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPublicKeys.defaultExpectation.params)
		}
	}

	return mmGetPublicKeys
}

// ExpectCtxParam1 sets up expected param ctx for SecretRepository.GetPublicKeys
func (mmGetPublicKeys *mSecretRepositoryMockGetPublicKeys) ExpectCtxParam1(ctx context.Context) *mSecretRepositoryMockGetPublicKeys {
	if mmGetPublicKeys.mock.funcGetPublicKeys != nil {
		mmGetPublicKeys.mock.t.Fatalf("SecretRepositoryMock.GetPublicKeys mock is already set by Set")
	}

	if mmGetPublicKeys.defaultExpectation == nil {
		mmGetPublicKeys.defaultExpectation = &SecretRepositoryMockGetPublicKeysExpectation{}
	}

	if mmGetPublicKeys.defaultExpectation.params != nil {
		mmGetPublicKeys.mock.t.Fatalf("SecretRepositoryMock.GetPublicKeys mock is already set by Expect")
	}

	if mmGetPublicKeys.defaultExpectation.paramPtrs == nil {
		mmGetPublicKeys.defaultExpectation.paramPtrs = &SecretRepositoryMockGetPublicKeysParamPtrs{}
	}
	mmGetPublicKeys.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPublicKeys.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPublicKeys
}

// ExpectKeyNameParam2 sets up expected param keyName for SecretRepository.GetPublicKeys
func (mmGetPublicKeys *mSecretRepositoryMockGetPublicKeys) ExpectKeyNameParam2(keyName string) *mSecretRepositoryMockGetPublicKeys {
	if mmGetPublicKeys.mock.funcGetPublicKeys != nil {
		mmGetPublicKeys.mock.t.Fatalf("SecretRepositoryMock.GetPublicKeys mock is already set by Set")
	}

	if mmGetPublicKeys.defaultExpectation == nil {
		mmGetPublicKeys.defaultExpectation = &SecretRepositoryMockGetPublicKeysExpectation{}
	}

	if mmGetPublicKeys.defaultExpectation.params != nil {
		mmGetPublicKeys.mock.t.Fatalf("SecretRepositoryMock.GetPublicKeys mock is already set by Expect")
	}

	if mmGetPublicKeys.defaultExpectation.paramPtrs == nil {
		mmGetPublicKeys.defaultExpectation.paramPtrs = &SecretRepositoryMockGetPublicKeysParamPtrs{}
	}
	mmGetPublicKeys.defaultExpectation.paramPtrs.keyName = &keyName
	mmGetPublicKeys.defaultExpectation.expectationOrigins.originKeyName = minimock.CallerInfo(1)

	return mmGetPublicKeys
}

// Inspect accepts an inspector function that has same arguments as the SecretRepository.GetPublicKeys
func (mmGetPublicKeys *mSecretRepositoryMockGetPublicKeys) Inspect(f func(ctx context.Context, keyName string)) *mSecretRepositoryMockGetPublicKeys {
	if mmGetPublicKeys.mock.inspectFuncGetPublicKeys != nil {
		mmGetPublicKeys.mock.t.Fatalf("Inspect function is already set for SecretRepositoryMock.GetPublicKeys")
	}

	mmGetPublicKeys.mock.inspectFuncGetPublicKeys = f

	return mmGetPublicKeys
}

// Return sets up results that will be returned by SecretRepository.GetPublicKeys
func (mmGetPublicKeys *mSecretRepositoryMockGetPublicKeys) Return(m1 map[string]string, err error) *SecretRepositoryMock {
	if mmGetPublicKeys.mock.funcGetPublicKeys != nil {
		mmGetPublicKeys.mock.t.Fatalf("SecretRepositoryMock.GetPublicKeys mock is already set by Set")
	}

	if mmGetPublicKeys.defaultExpectation == nil {
		mmGetPublicKeys.defaultExpectation = &SecretRepositoryMockGetPublicKeysExpectation{mock: mmGetPublicKeys.mock}
	}
	mmGetPublicKeys.defaultExpectation.results = &SecretRepositoryMockGetPublicKeysResults{m1, err}
	mmGetPublicKeys.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPublicKeys.mock
}

// Set uses given function f to mock the SecretRepository.GetPublicKeys method
func (mmGetPublicKeys *mSecretRepositoryMockGetPublicKeys) Set(f func(ctx context.Context, keyName string) (m1 map[string]string, err error)) *SecretRepositoryMock {
	if mmGetPublicKeys.defaultExpectation != nil {
		mmGetPublicKeys.mock.t.Fatalf("Default expectation is already set for the SecretRepository.GetPublicKeys method")
	}

	if len(mmGetPublicKeys.expectations) > 0 {
		mmGetPublicKeys.mock.t.Fatalf("Some expectations are already set for the SecretRepository.GetPublicKeys method")
	}

	mmGetPublicKeys.mock.funcGetPublicKeys = f
	mmGetPublicKeys.mock.funcGetPublicKeysOrigin = minimock.CallerInfo(1)
	return mmGetPublicKeys.mock
}

// When sets expectation for the SecretRepository.GetPublicKeys which will trigger the result defined by the following
// Then helper
func (mmGetPublicKeys *mSecretRepositoryMockGetPublicKeys) When(ctx context.Context, keyName string) *SecretRepositoryMockGetPublicKeysExpectation {
	if mmGetPublicKeys.mock.funcGetPublicKeys != nil {
		mmGetPublicKeys.mock.t.Fatalf("SecretRepositoryMock.GetPublicKeys mock is already set by Set")
	}

	expectation := &SecretRepositoryMockGetPublicKeysExpectation{
		mock:               mmGetPublicKeys.mock,
		params:             &SecretRepositoryMockGetPublicKeysParams{ctx, keyName},
		expectationOrigins: SecretRepositoryMockGetPublicKeysExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPublicKeys.expectations = append(mmGetPublicKeys.expectations, expectation)
	return expectation
}

// Then sets up SecretRepository.GetPublicKeys return parameters for the expectation previously defined by the When method
func (e *SecretRepositoryMockGetPublicKeysExpectation) Then(m1 map[string]string, err error) *SecretRepositoryMock {
	e.results = &SecretRepositoryMockGetPublicKeysResults{m1, err}
	return e.mock
}

// Times sets number of times SecretRepository.GetPublicKeys should be invoked
func (mmGetPublicKeys *mSecretRepositoryMockGetPublicKeys) Times(n uint64) *mSecretRepositoryMockGetPublicKeys {
	if n == 0 {
		mmGetPublicKeys.mock.t.Fatalf("Times of SecretRepositoryMock.GetPublicKeys mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPublicKeys.expectedInvocations, n)
	mmGetPublicKeys.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPublicKeys
}

func (mmGetPublicKeys *mSecretRepositoryMockGetPublicKeys) invocationsDone() bool {
	if len(mmGetPublicKeys.expectations) == 0 && mmGetPublicKeys.defaultExpectation == nil && mmGetPublicKeys.mock.funcGetPublicKeys == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPublicKeys.mock.afterGetPublicKeysCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPublicKeys.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPublicKeys implements mm_repository.SecretRepository
func (mmGetPublicKeys *SecretRepositoryMock) GetPublicKeys(ctx context.Context, keyName string) (m1 map[string]string, err error) {
	mm_atomic.AddUint64(&mmGetPublicKeys.beforeGetPublicKeysCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPublicKeys.afterGetPublicKeysCounter, 1)

	mmGetPublicKeys.t.Helper()

	if mmGetPublicKeys.inspectFuncGetPublicKeys != nil {
		mmGetPublicKeys.inspectFuncGetPublicKeys(ctx, keyName)
	}

	mm_params := SecretRepositoryMockGetPublicKeysParams{ctx, keyName}

	// Record call args
	mmGetPublicKeys.GetPublicKeysMock.mutex.Lock()
	mmGetPublicKeys.GetPublicKeysMock.callArgs = append(mmGetPublicKeys.GetPublicKeysMock.callArgs, &mm_params)
	mmGetPublicKeys.GetPublicKeysMock.mutex.Unlock()

	for _, e := range mmGetPublicKeys.GetPublicKeysMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmGetPublicKeys.GetPublicKeysMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPublicKeys.GetPublicKeysMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPublicKeys.GetPublicKeysMock.defaultExpectation.params
		mm_want_ptrs := mmGetPublicKeys.GetPublicKeysMock.defaultExpectation.paramPtrs

		mm_got := SecretRepositoryMockGetPublicKeysParams{ctx, keyName}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPublicKeys.t.Errorf("SecretRepositoryMock.GetPublicKeys got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPublicKeys.GetPublicKeysMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.keyName != nil && !minimock.Equal(*mm_want_ptrs.keyName, mm_got.keyName) {
				mmGetPublicKeys.t.Errorf("SecretRepositoryMock.GetPublicKeys got unexpected parameter keyName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPublicKeys.GetPublicKeysMock.defaultExpectation.expectationOrigins.originKeyName, *mm_want_ptrs.keyName, mm_got.keyName, minimock.Diff(*mm_want_ptrs.keyName, mm_got.keyName))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPublicKeys.t.Errorf("SecretRepositoryMock.GetPublicKeys got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPublicKeys.GetPublicKeysMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPublicKeys.GetPublicKeysMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPublicKeys.t.Fatal("No results are set for the SecretRepositoryMock.GetPublicKeys")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmGetPublicKeys.funcGetPublicKeys != nil {
		return mmGetPublicKeys.funcGetPublicKeys(ctx, keyName)
	}
	mmGetPublicKeys.t.Fatalf("Unexpected call to SecretRepositoryMock.GetPublicKeys. %v %v", ctx, keyName)
	return
}

// GetPublicKeysAfterCounter returns a count of finished SecretRepositoryMock.GetPublicKeys invocations
func (mmGetPublicKeys *SecretRepositoryMock) GetPublicKeysAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPublicKeys.afterGetPublicKeysCounter)
}

// GetPublicKeysBeforeCounter returns a count of SecretRepositoryMock.GetPublicKeys invocations
func (mmGetPublicKeys *SecretRepositoryMock) GetPublicKeysBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPublicKeys.beforeGetPublicKeysCounter)
}

// Calls returns a list of arguments used in each call to SecretRepositoryMock.GetPublicKeys.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPublicKeys *mSecretRepositoryMockGetPublicKeys) Calls() []*SecretRepositoryMockGetPublicKeysParams {
	mmGetPublicKeys.mutex.RLock()

	argCopy := make([]*SecretRepositoryMockGetPublicKeysParams, len(mmGetPublicKeys.callArgs))
	copy(argCopy, mmGetPublicKeys.callArgs)

	mmGetPublicKeys.mutex.RUnlock()

	return argCopy
}

// MinimockGetPublicKeysDone returns true if the count of the GetPublicKeys invocations corresponds
// the number of defined expectations
func (m *SecretRepositoryMock) MinimockGetPublicKeysDone() bool {
	if m.GetPublicKeysMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPublicKeysMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPublicKeysMock.invocationsDone()
}

// MinimockGetPublicKeysInspect logs each unmet expectation
func (m *SecretRepositoryMock) MinimockGetPublicKeysInspect() {
	for _, e := range m.GetPublicKeysMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SecretRepositoryMock.GetPublicKeys at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPublicKeysCounter := mm_atomic.LoadUint64(&m.afterGetPublicKeysCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPublicKeysMock.defaultExpectation != nil && afterGetPublicKeysCounter < 1 {
		if m.GetPublicKeysMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SecretRepositoryMock.GetPublicKeys at\n%s", m.GetPublicKeysMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SecretRepositoryMock.GetPublicKeys at\n%s with params: %#v", m.GetPublicKeysMock.defaultExpectation.expectationOrigins.origin, *m.GetPublicKeysMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPublicKeys != nil && afterGetPublicKeysCounter < 1 {
		m.t.Errorf("Expected call to SecretRepositoryMock.GetPublicKeys at\n%s", m.funcGetPublicKeysOrigin)
	}

	if !m.GetPublicKeysMock.invocationsDone() && afterGetPublicKeysCounter > 0 {
		m.t.Errorf("Expected %d calls to SecretRepositoryMock.GetPublicKeys at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPublicKeysMock.expectedInvocations), m.GetPublicKeysMock.expectedInvocationsOrigin, afterGetPublicKeysCounter)
	}
}

type mSecretRepositoryMockSignJWT struct {
	optional           bool
	mock               *SecretRepositoryMock
	defaultExpectation *SecretRepositoryMockSignJWTExpectation
	expectations       []*SecretRepositoryMockSignJWTExpectation

	callArgs []*SecretRepositoryMockSignJWTParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// SecretRepositoryMockSignJWTExpectation specifies expectation struct of the SecretRepository.SignJWT
type SecretRepositoryMockSignJWTExpectation struct {
	mock               *SecretRepositoryMock
	params             *SecretRepositoryMockSignJWTParams
	paramPtrs          *SecretRepositoryMockSignJWTParamPtrs
	expectationOrigins SecretRepositoryMockSignJWTExpectationOrigins
	results            *SecretRepositoryMockSignJWTResults
	returnOrigin       string
	Counter            uint64
}

// SecretRepositoryMockSignJWTParams contains parameters of the SecretRepository.SignJWT
type SecretRepositoryMockSignJWTParams struct {
	ctx     context.Context
	data    string
	keyName string
}

// SecretRepositoryMockSignJWTParamPtrs contains pointers to parameters of the SecretRepository.SignJWT
type SecretRepositoryMockSignJWTParamPtrs struct {
	ctx     *context.Context
	data    *string
	keyName *string
}

// SecretRepositoryMockSignJWTResults contains results of the SecretRepository.SignJWT
type SecretRepositoryMockSignJWTResults struct {
	s1  string
	err error
}

// SecretRepositoryMockSignJWTOrigins contains origins of expectations of the SecretRepository.SignJWT
type SecretRepositoryMockSignJWTExpectationOrigins struct {
	origin        string
	originCtx     string
	originData    string
	originKeyName string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSignJWT *mSecretRepositoryMockSignJWT) Optional() *mSecretRepositoryMockSignJWT {
	mmSignJWT.optional = true
	return mmSignJWT
}

// Expect sets up expected params for SecretRepository.SignJWT
func (mmSignJWT *mSecretRepositoryMockSignJWT) Expect(ctx context.Context, data string, keyName string) *mSecretRepositoryMockSignJWT {
	if mmSignJWT.mock.funcSignJWT != nil {
		mmSignJWT.mock.t.Fatalf("SecretRepositoryMock.SignJWT mock is already set by Set")
	}

	if mmSignJWT.defaultExpectation == nil {
		mmSignJWT.defaultExpectation = &SecretRepositoryMockSignJWTExpectation{}
	}

	if mmSignJWT.defaultExpectation.paramPtrs != nil {
		mmSignJWT.mock.t.Fatalf("SecretRepositoryMock.SignJWT mock is already set by ExpectParams functions")
	}

	mmSignJWT.defaultExpectation.params = &SecretRepositoryMockSignJWTParams{ctx, data, keyName}
	mmSignJWT.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSignJWT.expectations {
		if minimock.Equal(e.params, mmSignJWT.defaultExpectation.params) {
			mmSignJWT.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSignJWT.defaultExpectation.params)
		}
	}

	return mmSignJWT
}

// ExpectCtxParam1 sets up expected param ctx for SecretRepository.SignJWT
func (mmSignJWT *mSecretRepositoryMockSignJWT) ExpectCtxParam1(ctx context.Context) *mSecretRepositoryMockSignJWT {
	if mmSignJWT.mock.funcSignJWT != nil {
		mmSignJWT.mock.t.Fatalf("SecretRepositoryMock.SignJWT mock is already set by Set")
	}

	if mmSignJWT.defaultExpectation == nil {
		mmSignJWT.defaultExpectation = &SecretRepositoryMockSignJWTExpectation{}
	}

	if mmSignJWT.defaultExpectation.params != nil {
		mmSignJWT.mock.t.Fatalf("SecretRepositoryMock.SignJWT mock is already set by Expect")
	}

	if mmSignJWT.defaultExpectation.paramPtrs == nil {
		mmSignJWT.defaultExpectation.paramPtrs = &SecretRepositoryMockSignJWTParamPtrs{}
	}
	mmSignJWT.defaultExpectation.paramPtrs.ctx = &ctx
	mmSignJWT.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSignJWT
}

// ExpectDataParam2 sets up expected param data for SecretRepository.SignJWT
func (mmSignJWT *mSecretRepositoryMockSignJWT) ExpectDataParam2(data string) *mSecretRepositoryMockSignJWT {
	if mmSignJWT.mock.funcSignJWT != nil {
		mmSignJWT.mock.t.Fatalf("SecretRepositoryMock.SignJWT mock is already set by Set")
	}

	if mmSignJWT.defaultExpectation == nil {
		mmSignJWT.defaultExpectation = &SecretRepositoryMockSignJWTExpectation{}
	}

	if mmSignJWT.defaultExpectation.params != nil {
		mmSignJWT.mock.t.Fatalf("SecretRepositoryMock.SignJWT mock is already set by Expect")
	}

	if mmSignJWT.defaultExpectation.paramPtrs == nil {
		mmSignJWT.defaultExpectation.paramPtrs = &SecretRepositoryMockSignJWTParamPtrs{}
	}
	mmSignJWT.defaultExpectation.paramPtrs.data = &data
	mmSignJWT.defaultExpectation.expectationOrigins.originData = minimock.CallerInfo(1)

	return mmSignJWT
}

// ExpectKeyNameParam3 sets up expected param keyName for SecretRepository.SignJWT
func (mmSignJWT *mSecretRepositoryMockSignJWT) ExpectKeyNameParam3(keyName string) *mSecretRepositoryMockSignJWT {
	if mmSignJWT.mock.funcSignJWT != nil {
		mmSignJWT.mock.t.Fatalf("SecretRepositoryMock.SignJWT mock is already set by Set")
	}

	if mmSignJWT.defaultExpectation == nil {
		mmSignJWT.defaultExpectation = &SecretRepositoryMockSignJWTExpectation{}
	}

	if mmSignJWT.defaultExpectation.params != nil {
		mmSignJWT.mock.t.Fatalf("SecretRepositoryMock.SignJWT mock is already set by Expect")
	}

	if mmSignJWT.defaultExpectation.paramPtrs == nil {
		mmSignJWT.defaultExpectation.paramPtrs = &SecretRepositoryMockSignJWTParamPtrs{}
	}
	mmSignJWT.defaultExpectation.paramPtrs.keyName = &keyName
	mmSignJWT.defaultExpectation.expectationOrigins.originKeyName = minimock.CallerInfo(1)

	return mmSignJWT
}

// Inspect accepts an inspector function that has same arguments as the SecretRepository.SignJWT
func (mmSignJWT *mSecretRepositoryMockSignJWT) Inspect(f func(ctx context.Context, data string, keyName string)) *mSecretRepositoryMockSignJWT {
	if mmSignJWT.mock.inspectFuncSignJWT != nil {
		mmSignJWT.mock.t.Fatalf("Inspect function is already set for SecretRepositoryMock.SignJWT")
	}

	mmSignJWT.mock.inspectFuncSignJWT = f

	return mmSignJWT
}

// Return sets up results that will be returned by SecretRepository.SignJWT
func (mmSignJWT *mSecretRepositoryMockSignJWT) Return(s1 string, err error) *SecretRepositoryMock {
	if mmSignJWT.mock.funcSignJWT != nil {
		mmSignJWT.mock.t.Fatalf("SecretRepositoryMock.SignJWT mock is already set by Set")
	}

	if mmSignJWT.defaultExpectation == nil {
		mmSignJWT.defaultExpectation = &SecretRepositoryMockSignJWTExpectation{mock: mmSignJWT.mock}
	}
	mmSignJWT.defaultExpectation.results = &SecretRepositoryMockSignJWTResults{s1, err}
	mmSignJWT.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSignJWT.mock
}

// Set uses given function f to mock the SecretRepository.SignJWT method
func (mmSignJWT *mSecretRepositoryMockSignJWT) Set(f func(ctx context.Context, data string, keyName string) (s1 string, err error)) *SecretRepositoryMock {
	if mmSignJWT.defaultExpectation != nil {
		mmSignJWT.mock.t.Fatalf("Default expectation is already set for the SecretRepository.SignJWT method")
	}

	if len(mmSignJWT.expectations) > 0 {
		mmSignJWT.mock.t.Fatalf("Some expectations are already set for the SecretRepository.SignJWT method")
	}

	mmSignJWT.mock.funcSignJWT = f
	mmSignJWT.mock.funcSignJWTOrigin = minimock.CallerInfo(1)
	return mmSignJWT.mock
}

// When sets expectation for the SecretRepository.SignJWT which will trigger the result defined by the following
// Then helper
func (mmSignJWT *mSecretRepositoryMockSignJWT) When(ctx context.Context, data string, keyName string) *SecretRepositoryMockSignJWTExpectation {
	if mmSignJWT.mock.funcSignJWT != nil {
		mmSignJWT.mock.t.Fatalf("SecretRepositoryMock.SignJWT mock is already set by Set")
	}

	expectation := &SecretRepositoryMockSignJWTExpectation{
		mock:               mmSignJWT.mock,
		params:             &SecretRepositoryMockSignJWTParams{ctx, data, keyName},
		expectationOrigins: SecretRepositoryMockSignJWTExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSignJWT.expectations = append(mmSignJWT.expectations, expectation)
	return expectation
}

// Then sets up SecretRepository.SignJWT return parameters for the expectation previously defined by the When method
func (e *SecretRepositoryMockSignJWTExpectation) Then(s1 string, err error) *SecretRepositoryMock {
	e.results = &SecretRepositoryMockSignJWTResults{s1, err}
	return e.mock
}

// Times sets number of times SecretRepository.SignJWT should be invoked
func (mmSignJWT *mSecretRepositoryMockSignJWT) Times(n uint64) *mSecretRepositoryMockSignJWT {
	if n == 0 {
		mmSignJWT.mock.t.Fatalf("Times of SecretRepositoryMock.SignJWT mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSignJWT.expectedInvocations, n)
	mmSignJWT.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSignJWT
}

func (mmSignJWT *mSecretRepositoryMockSignJWT) invocationsDone() bool {
	if len(mmSignJWT.expectations) == 0 && mmSignJWT.defaultExpectation == nil && mmSignJWT.mock.funcSignJWT == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSignJWT.mock.afterSignJWTCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSignJWT.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SignJWT implements mm_repository.SecretRepository
func (mmSignJWT *SecretRepositoryMock) SignJWT(ctx context.Context, data string, keyName string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmSignJWT.beforeSignJWTCounter, 1)
	defer mm_atomic.AddUint64(&mmSignJWT.afterSignJWTCounter, 1)

	mmSignJWT.t.Helper()

	if mmSignJWT.inspectFuncSignJWT != nil {
		mmSignJWT.inspectFuncSignJWT(ctx, data, keyName)
	}

	mm_params := SecretRepositoryMockSignJWTParams{ctx, data, keyName}

	// Record call args
	mmSignJWT.SignJWTMock.mutex.Lock()
	mmSignJWT.SignJWTMock.callArgs = append(mmSignJWT.SignJWTMock.callArgs, &mm_params)
	mmSignJWT.SignJWTMock.mutex.Unlock()

	for _, e := range mmSignJWT.SignJWTMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmSignJWT.SignJWTMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSignJWT.SignJWTMock.defaultExpectation.Counter, 1)
		mm_want := mmSignJWT.SignJWTMock.defaultExpectation.params
		mm_want_ptrs := mmSignJWT.SignJWTMock.defaultExpectation.paramPtrs

		mm_got := SecretRepositoryMockSignJWTParams{ctx, data, keyName}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSignJWT.t.Errorf("SecretRepositoryMock.SignJWT got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSignJWT.SignJWTMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.data != nil && !minimock.Equal(*mm_want_ptrs.data, mm_got.data) {
				mmSignJWT.t.Errorf("SecretRepositoryMock.SignJWT got unexpected parameter data, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSignJWT.SignJWTMock.defaultExpectation.expectationOrigins.originData, *mm_want_ptrs.data, mm_got.data, minimock.Diff(*mm_want_ptrs.data, mm_got.data))
			}

			if mm_want_ptrs.keyName != nil && !minimock.Equal(*mm_want_ptrs.keyName, mm_got.keyName) {
				mmSignJWT.t.Errorf("SecretRepositoryMock.SignJWT got unexpected parameter keyName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSignJWT.SignJWTMock.defaultExpectation.expectationOrigins.originKeyName, *mm_want_ptrs.keyName, mm_got.keyName, minimock.Diff(*mm_want_ptrs.keyName, mm_got.keyName))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSignJWT.t.Errorf("SecretRepositoryMock.SignJWT got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSignJWT.SignJWTMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSignJWT.SignJWTMock.defaultExpectation.results
		if mm_results == nil {
			mmSignJWT.t.Fatal("No results are set for the SecretRepositoryMock.SignJWT")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmSignJWT.funcSignJWT != nil {
		return mmSignJWT.funcSignJWT(ctx, data, keyName)
	}
	mmSignJWT.t.Fatalf("Unexpected call to SecretRepositoryMock.SignJWT. %v %v %v", ctx, data, keyName)
	return
}

// SignJWTAfterCounter returns a count of finished SecretRepositoryMock.SignJWT invocations
func (mmSignJWT *SecretRepositoryMock) SignJWTAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignJWT.afterSignJWTCounter)
}

// SignJWTBeforeCounter returns a count of SecretRepositoryMock.SignJWT invocations
func (mmSignJWT *SecretRepositoryMock) SignJWTBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSignJWT.beforeSignJWTCounter)
}

// Calls returns a list of arguments used in each call to SecretRepositoryMock.SignJWT.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSignJWT *mSecretRepositoryMockSignJWT) Calls() []*SecretRepositoryMockSignJWTParams {
	mmSignJWT.mutex.RLock()

	argCopy := make([]*SecretRepositoryMockSignJWTParams, len(mmSignJWT.callArgs))
	copy(argCopy, mmSignJWT.callArgs)

	mmSignJWT.mutex.RUnlock()

	return argCopy
}

// MinimockSignJWTDone returns true if the count of the SignJWT invocations corresponds
// the number of defined expectations
func (m *SecretRepositoryMock) MinimockSignJWTDone() bool {
	if m.SignJWTMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SignJWTMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SignJWTMock.invocationsDone()
}

// MinimockSignJWTInspect logs each unmet expectation
func (m *SecretRepositoryMock) MinimockSignJWTInspect() {
	for _, e := range m.SignJWTMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SecretRepositoryMock.SignJWT at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSignJWTCounter := mm_atomic.LoadUint64(&m.afterSignJWTCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SignJWTMock.defaultExpectation != nil && afterSignJWTCounter < 1 {
		if m.SignJWTMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to SecretRepositoryMock.SignJWT at\n%s", m.SignJWTMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to SecretRepositoryMock.SignJWT at\n%s with params: %#v", m.SignJWTMock.defaultExpectation.expectationOrigins.origin, *m.SignJWTMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSignJWT != nil && afterSignJWTCounter < 1 {
		m.t.Errorf("Expected call to SecretRepositoryMock.SignJWT at\n%s", m.funcSignJWTOrigin)
	}

	if !m.SignJWTMock.invocationsDone() && afterSignJWTCounter > 0 {
		m.t.Errorf("Expected %d calls to SecretRepositoryMock.SignJWT at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SignJWTMock.expectedInvocations), m.SignJWTMock.expectedInvocationsOrigin, afterSignJWTCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SecretRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetKIDInspect()

			m.MinimockGetPublicKeysInspect()

			m.MinimockSignJWTInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SecretRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SecretRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetKIDDone() &&
		m.MinimockGetPublicKeysDone() &&
		m.MinimockSignJWTDone()
}
